;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.03
;// License Type  : Full License
;// Limitations   : PIC12,PIC16 max code size:Unlimited, max RAM banks:Unlimited, Non commercial use only
;/////////////////////////////////////////////////////////////////////////////////

/*********************************************************************
 *                  Flowcode CAL Delays File
 *
 * File: PIC_CAL_Delay.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 *
 *
 *
 */

//Original Byte Delays
void Wdt_Delay_S(char delay);
void Wdt_Delay_Ms(char delay);

//New Int Delays
void FCI_DELAYINT_US(MX_UINT16 Delay);

void FCI_DELAYINT_MS(MX_UINT16 Delay);
void FCI_DELAYINTWDT_MS(MX_UINT16 Delay);

void FCI_DELAYINT_S(MX_UINT16 Delay);
void FCI_DELAYINTWDT_S(MX_UINT16 Delay);


#ifdef HI_TECH_C

	#define nop()	asm("NOP")

	void delay_10us(char del);
	void delay_us(char del);
	void delay_ms(char del);
	void delay_s(char del);

	void delay_10us(char del)
	{
		char count;
		for(count=0; count<10; count++)
		{
			delay_us(del);
		}
	}

	void delay_us(char del)
	{
		while (del > 1)
		{
			__delay_us(1);
			del = del - 1;
		}
	}

	void delay_ms(char del)
	{
		while (del > 1)
		{
			__delay_ms(1);
			del = del - 1;
		}
	}

	void delay_s(char del)
	{
		char i;
		for(i=0; i<del; i++)
		{
			delay_ms(250);
			delay_ms(250);
			delay_ms(250);
			delay_ms(250);
		}
	}

#endif

void Wdt_Delay_S(char delay)
{
    char i;
    short j;
    for (i=0; i<delay; i++)
    {
        for (j=0; j<999; j++)
        {
            Wdt_Delay_Ms(1);
        }
    }
}

void Wdt_Delay_Ms(char delay)

{
    char i;
    for (i=0; i<delay; i++)
0079  01C8  	CLRF Wdt_Delay__0003E_1_i
007A        label10
007A  0847  	MOVF Wdt_Delay__0003E_arg_delay, W
007B  0248  	SUBWF Wdt_Delay__0003E_1_i, W
007C  1803  	BTFSC STATUS,C
0082  0AC8  	INCF Wdt_Delay__0003E_1_i, F
0083  287A  	GOTO	label10

    {
        MX_CLEAR_WATCHDOG;        //Clear Watchdog Timer
007E  0064  	CLRWDT

        delay_ms(1);
007F  3001  	MOVLW 0x01
0080  00C9  	MOVWF delay_ms_00000_arg_del
0081  2015  	CALL delay_ms_00000

    }
}
007D  0008  	RETURN



void FCI_DELAYINT_US(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	delay_us(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		delay_us(Delay & 0xFF);
}

void FCI_DELAYINT_MS(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	delay_ms(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		delay_ms(Delay & 0xFF);
}

void FCI_DELAYINTWDT_MS(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	Wdt_Delay_Ms(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		Wdt_Delay_Ms(Delay & 0xFF);
}

void FCI_DELAYINT_S(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	delay_s(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		delay_s(Delay & 0xFF);
}

void FCI_DELAYINTWDT_S(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	Wdt_Delay_S(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		Wdt_Delay_S(Delay & 0xFF);
}



//************************************************************************************
//**  
//**  File name:     G:\bcit_flowcode_projecs\AtoDconversion.c
//**  Title:         
//**  Description:   
//**  
//**  Generated by:  Flowcode v5.5.2.1
//**  Date:          Monday, August 11, 2014 12:54:40
//**  Licence:       50 User
//**  Registered to: BCITETCC2012
//**  Licence key:   91DZ5U
//**  
//**  
//**     NOT FOR COMMERCIAL USE
//**  
//**  http://www.matrixmultimedia.com
//**  
//************************************************************************************


#define MX_PIC

#define MX_USES_UINT8 1
#define MX_USES_SINT16 0
#define MX_USES_CHAR 0
#define MX_USES_FLOAT 0
#define MX_USES_SINT32 0
#define MX_USES_BOOL 1
#define MX_USES_UINT16 0
#define MX_USES_UINT32 0
//Defines for microcontroller
#define P16F877
#define FC_CAL_PIC
#define MX_ADC
#define MX_ADC_TYPE_30
#define MX_ADC_BITS_10
#define MX_EE
#define MX_EE_TYPE2
#define MX_EE_SIZE 256
#define MX_SPI_1
#define MX_SPI_1_MISO_PORT portc
#define MX_SPI_1_MISO_TRIS trisc
#define MX_SPI_1_MISO_PIN 4
#define MX_SPI_1_MOSI_PORT portc
#define MX_SPI_1_MOSI_TRIS trisc
#define MX_SPI_1_MOSI_PIN 5
#define MX_SPI_1_CLK_PORT portc
#define MX_SPI_1_CLK_TRIS trisc
#define MX_SPI_1_CLK_PIN 3
#define MX_SPI_1_SS_PORT portc
#define MX_SPI_1_SS_TRIS trisc
#define MX_UART_1
#define MX_UART_1_TX_PORT portc
#define MX_UART_1_TX_TRIS trisc
#define MX_UART_1_TX_PIN 6
#define MX_UART_1_RX_PORT portc
#define MX_UART_1_RX_TRIS trisc
#define MX_UART_1_RX_PIN 7
#define MX_I2C
#define MX_MI2C
#define MX_I2C_1
#define MX_I2C_1_SDA_PORT portc
#define MX_I2C_1_SDA_TRIS trisc
#define MX_I2C_1_SDA_PIN 4
#define MX_I2C_1_SCL_PORT portc
#define MX_I2C_1_SCL_TRIS trisc
#define MX_I2C_1_SCL_PIN 3
#define MX_PWM
#define MX_PWM_CNT 2
#define MX_PWM_PSCA1
#define MX_PWM_PSCA4
#define MX_PWM_PSCA16
#define MX_PWM_1_PORT portc
#define MX_PWM_1_TRIS trisc
#define MX_PWM_1_PIN 2
#define MX_PWM_2_PORT portc
#define MX_PWM_2_TRIS trisc
#define MX_PWM_2_PIN 1

//Functions
#define MX_CLK_SPEED 19660800
#ifdef _BOOSTC
#include <system.h>
#endif
#ifdef HI_TECH_C
#include <pic.h>
#endif

//Configuration data
#ifdef _BOOSTC
#pragma DATA 0x2007, 0x3f7a
#endif
#ifdef HI_TECH_C
__CONFIG(0x3f7a);
#endif

//Internal functions
#include "C:\Program Files (x86)\Flowcode\v5\FCD\internals.c"

//Macro function declarations


//Variable declarations
#define FCV_FALSE (0)
#define FCV_TRUE (1)
MX_UINT8 FCV_VOLTAGE;
MX_UINT8 FCV_VOLTAGE6B;




//ADC(0): //Defines:

/**** Macro Substitutions ****
a = Unique Reference
b = Which ADC Channel
c = Acquisition time
d = Conversion Speed
e = VRef+ Option
f = VRef Voltage x 0.01V
******************************/

//Common Defines

#define ADC_4_MX_ADC_CHANNEL	0
#define ADC_4_MX_ADC_ACTIME	40
#define ADC_4_MX_ADC_CONVSP	3
#define ADC_4_MX_ADC_VREFOP	0
#define ADC_4_MX_ADC_VREFVOL	500

#ifndef MX_ADC_CHANNEL_0
 #define MX_ADC_CHANNEL_0			//Inform CAL ADC channel 0 is now in use.
#endif

#ifndef MX_ADC_REF					//Inform CAL ADC peripheral is now in use
 #define MX_ADC_REF
#endif

extern void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge);
extern MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode);
extern void FC_CAL_Disable_ADC (void);




//ADC(0): //Macro function declarations

void FCD_ADC0_SampleADC();
MX_UINT8 FCD_ADC0_ReadAsByte();
MX_UINT16 FCD_ADC0_ReadAsInt();
MX_FLOAT FCD_ADC0_ReadAsVoltage();
void FCD_ADC0_ReadAsString(MX_CHAR* FCR_RETVAL, MX_UINT8 FCR_RETVAL_SIZE);
void FCD_ADC0_ADC_RAW_Configure_Channel();
MX_UINT8 FCD_ADC0_ADC_RAW_Sample_Channel_Byte();
MX_UINT16 FCD_ADC0_ADC_RAW_Sample_Channel_Int();
MX_UINT8 FCD_ADC0_ADC_RAW_Average_Channel_Byte(MX_UINT8 NumSamples, MX_UINT8 DelayUs);
MX_UINT16 FCD_ADC0_ADC_RAW_Average_Channel_Int(MX_UINT8 NumSamples, MX_UINT8 DelayUs);
void FCD_ADC0_ADC_RAW_Disable_Channel();


//LCDDisplay(0): //Defines:

/**** Macro Substitutions ****
a = Unique Component Reference Number
b = D1 Port Letter
c = D2 Port Letter
d = D3 Port Letter
e = D4 Port Letter
f = RS Port Letter
g = E Port Letter
h = Data 1_Pin
i = Data 2 Pin
j = Data 3 Pin
k = Data 4 Pin
l = RS Pin
m = Enable Pin
n = Row Count
o = Column Count
******************************/

	//component connections
	//Port pin lat workaround for 8-bit PIC devices running >= 32MHz
	//seems we need this mod for 19660800 16F1937 so changed to >= 16MHz

  #ifdef FC_CAL_PIC
   #if MX_CLK_SPEED >= 32000000
	#define LCD_5__PORT0    latc
	#define LCD_5__PORT1    latc
	#define LCD_5__PORT2    latc
	#define LCD_5__PORT3    latc
	#define LCD_5__PORT4    latc
	#define LCD_5__PORT5    latc
   #else
    #ifdef MX_LCD_PORT_LAT
	 #define LCD_5__PORT0    latc
	 #define LCD_5__PORT1    latc
	 #define LCD_5__PORT2    latc
	 #define LCD_5__PORT3    latc
	 #define LCD_5__PORT4    latc
	 #define LCD_5__PORT5    latc
    #else
	 #define LCD_5__PORT0    portc
	 #define LCD_5__PORT1    portc
	 #define LCD_5__PORT2    portc
	 #define LCD_5__PORT3    portc
	 #define LCD_5__PORT4    portc
	 #define LCD_5__PORT5    portc
	#endif
   #endif
  #else
	#define LCD_5__PORT0    portc
	#define LCD_5__PORT1    portc
	#define LCD_5__PORT2    portc
	#define LCD_5__PORT3    portc
	#define LCD_5__PORT4    portc
	#define LCD_5__PORT5    portc
  #endif

	#define LCD_5__TRIS0    trisc
	#define LCD_5__TRIS1    trisc
	#define LCD_5__TRIS2    trisc
	#define LCD_5__TRIS3    trisc
	#define LCD_5__TRIS4    trisc
	#define LCD_5__TRIS5    trisc
	#define LCD_5__BIT0    	0
	#define LCD_5__BIT1    	1
	#define LCD_5__BIT2    	2
	#define LCD_5__BIT3    	3
	#define LCD_5__RS      	4
	#define LCD_5__E       	5
	#define LCD_5__ROWCNT	2
	#define LCD_5__COLCNT	16

	#ifdef _BOOSTC
	  #define LCD_5__DELAY   delay_10us(10)
	#endif
	#ifdef _C2C_
	  #define LCD_5__DELAY   delay_us(100)
	#endif
	#ifdef HI_TECH_C
	  #define LCD_5__DELAY   __delay_us(120)
	#endif
	#ifndef LCD_5__DELAY
	  #define LCD_5__DELAY   delay_us(100)
	#endif




//LCDDisplay(0): //Macro function declarations

void FCD_LCDDisplay0_RawSend(MX_UINT8 in, MX_UINT8 mask);
void FCD_LCDDisplay0_Start();
void FCD_LCDDisplay0_Clear();
void FCD_LCDDisplay0_PrintASCII(MX_UINT8 Character);
void FCD_LCDDisplay0_Command(MX_UINT8 in);
void FCD_LCDDisplay0_Cursor(MX_UINT8 x, MX_UINT8 y);
void FCD_LCDDisplay0_PrintNumber(MX_SINT16 Number);
void FCD_LCDDisplay0_PrintString(MX_STRING String, MX_UINT8 MSZ_String);
void FCD_LCDDisplay0_ScrollDisplay(MX_UINT8 Direction, MX_UINT8 Num_Positions);
void FCD_LCDDisplay0_ClearLine(MX_UINT8 Line);
void FCD_LCDDisplay0_RAM_Write(MX_UINT8 nIdx, MX_UINT8 d0, MX_UINT8 d1, MX_UINT8 d2, MX_UINT8 d3, MX_UINT8 d4, MX_UINT8 d5, MX_UINT8 d6, MX_UINT8 d7);



//ADC(0): //Macro implementations


void FCD_ADC0_SampleADC()
{
	
	    //unused

}

MX_UINT8 FCD_ADC0_ReadAsByte()

{
	
		MX_UINT8 retVal;

		//Configure & Enable ADC Channel
		FC_CAL_Enable_ADC ( ADC_4_MX_ADC_CHANNEL , ADC_4_MX_ADC_CONVSP , ADC_4_MX_ADC_VREFOP , ADC_4_MX_ADC_ACTIME );
028F  1283  	BCF STATUS, RP0
0290  1303  	BCF STATUS, RP1
0291  01C8  	CLRF FC_CAL_Ena_00051_arg_Channel
0292  3003  	MOVLW 0x03
0293  00C9  	MOVWF FC_CAL_Ena_00051_arg_Conv_Speed
0294  01CA  	CLRF FC_CAL_Ena_00051_arg_Vref
0295  3028  	MOVLW 0x28
0296  00CB  	MOVWF FC_CAL_Ena_00051_arg_T_Charge
0297  20A8  	CALL FC_CAL_Ena_00051


		retVal = FC_CAL_Sample_ADC( 0 );				//Perform Sample - Return as byte
0298  01C8  	CLRF FC_CAL_Sam_00052_arg_Sample_Mode
0299  2084  	CALL FC_CAL_Sam_00052
029A  084B  	MOVF CompTempVarRet2201, W
029B  00C7  	MOVWF FCD_ADC0_R_00055_1_retVal


		FC_CAL_Disable_ADC ();
029C  20EB  	CALL FC_CAL_Dis_00053


		return (retVal);
029D  0847  	MOVF FCD_ADC0_R_00055_1_retVal, W
029E  00C8  	MOVWF CompTempVarRet2207


}
029F  0008  	RETURN


MX_UINT16 FCD_ADC0_ReadAsInt()
{
	
		MX_UINT16 retVal;

		//Configure & Enable ADC Channel
		FC_CAL_Enable_ADC ( ADC_4_MX_ADC_CHANNEL , ADC_4_MX_ADC_CONVSP , ADC_4_MX_ADC_VREFOP , ADC_4_MX_ADC_ACTIME );

		retVal = FC_CAL_Sample_ADC( 1 );				//Perform Sample - Return as MX_UINT16

		FC_CAL_Disable_ADC ();

		return (retVal);

}

MX_FLOAT FCD_ADC0_ReadAsVoltage()
{
	
		MX_UINT16 iSample;
		MX_FLOAT fSample, fVoltage, fVperDiv;

		//Configure & Enable ADC Channel
		FC_CAL_Enable_ADC ( ADC_4_MX_ADC_CHANNEL , ADC_4_MX_ADC_CONVSP , ADC_4_MX_ADC_VREFOP , ADC_4_MX_ADC_ACTIME );

	  #ifdef MX_ADC_BITS_8
		iSample = FC_CAL_Sample_ADC( 0 );								//Perform Sample - Return as byte
	  #else
		iSample = FC_CAL_Sample_ADC( 1 );								//Perform Sample - Return as MX_UINT16
	  #endif

	  	FC_CAL_Disable_ADC ();											//Switch off ADC peripheral
		fVoltage = flt_fromi( ADC_4_MX_ADC_VREFVOL );						//Convert reference voltage count to floating point (0 - 500 x 10mV)
		fVoltage = flt_mul(fVoltage, 0.01);								//Convert reference voltage count to actual voltage (0 - 5)

	  #ifdef MX_ADC_BITS_8
		fVperDiv = flt_mul(fVoltage, 0.00390625);						//Convert actual voltage to voltage per division (VRef / 256)
	  #endif
	  #ifdef MX_ADC_BITS_10
		fVperDiv = flt_mul(fVoltage, 0.000976);							//Convert actual voltage to voltage per division (VRef / 1024)
	  #endif
	  #ifdef MX_ADC_BITS_12
		fVperDiv = flt_mul(fVoltage, 0.00024414);						//Convert actual voltage to voltage per division (VRef / 4096)
	  #endif

		fSample = flt_fromi(iSample);									//Convert to floating point variable
		fVoltage = flt_mul(fSample, fVperDiv);							//Calculate floating point voltage

		return (fVoltage);

}

void FCD_ADC0_ReadAsString(MX_CHAR* FCR_RETVAL, MX_UINT8 FCR_RETVAL_SIZE)
{
	
		MX_FLOAT fVoltage;

		fVoltage = FCD_ADC0_ReadAsVoltage();
		FCI_FLOAT_TO_STRING(fVoltage, 2, FCR_RETVAL, FCR_RETVAL_SIZE);	//Convert to String

}

void FCD_ADC0_ADC_RAW_Configure_Channel()
{
	
		//Configure & Enable ADC Channel
		FC_CAL_Enable_ADC ( ADC_4_MX_ADC_CHANNEL , ADC_4_MX_ADC_CONVSP , ADC_4_MX_ADC_VREFOP , ADC_4_MX_ADC_ACTIME );

}

MX_UINT8 FCD_ADC0_ADC_RAW_Sample_Channel_Byte()
{
	
		return FC_CAL_Sample_ADC( 0 );									//Perform Sample - Return as byte

}

MX_UINT16 FCD_ADC0_ADC_RAW_Sample_Channel_Int()
{
	
		return FC_CAL_Sample_ADC( 1 );									//Perform Sample - Return as MX_UINT16

}

MX_UINT8 FCD_ADC0_ADC_RAW_Average_Channel_Byte(MX_UINT8 NumSamples, MX_UINT8 DelayUs)
{
	
		MX_UINT32 average = 0;
		MX_UINT8 count;

		for (count=0; count<NumSamples; count++)
		{
			average = average + FC_CAL_Sample_ADC( 0 );					//Perform Sample - Return as byte - add to average

			if (DelayUs)
				delay_us(DelayUs);										//If delay is not 0 then pause between samples
		}
		average = average / count;

		return (average & 0xFF);										//Return average as byte

}

MX_UINT16 FCD_ADC0_ADC_RAW_Average_Channel_Int(MX_UINT8 NumSamples, MX_UINT8 DelayUs)
{
	
		MX_UINT32 average = 0;
		MX_UINT8 count;

		for (count=0; count<NumSamples; count++)
		{
			average = average + FC_CAL_Sample_ADC( 1 );					//Perform Sample - Return as MX_UINT16 - add to average

			if (DelayUs)
				delay_us(DelayUs);										//If delay is not 0 then pause between samples
		}
		average = average / count;

		return (average & 0x1FFF);										//Return average as MX_SINT16

}

void FCD_ADC0_ADC_RAW_Disable_Channel()
{
	
		FC_CAL_Disable_ADC ();											//Disable ADC Channel

}



//LCDDisplay(0): //Macro implementations


void FCD_LCDDisplay0_RawSend(MX_UINT8 in, MX_UINT8 mask)

{
	
		MX_UINT8 pt;

		FC_CAL_Bit_Low(LCD_5__PORT0, LCD_5__BIT0);
00FA  1007  	BCF gbl_portc,0

		FC_CAL_Bit_Low(LCD_5__PORT1, LCD_5__BIT1);
00FB  1087  	BCF gbl_portc,1

		FC_CAL_Bit_Low(LCD_5__PORT2, LCD_5__BIT2);
00FC  1107  	BCF gbl_portc,2

		FC_CAL_Bit_Low(LCD_5__PORT3, LCD_5__BIT3);
00FD  1187  	BCF gbl_portc,3

		FC_CAL_Bit_Low(LCD_5__PORT4, LCD_5__RS);
00FE  1207  	BCF gbl_portc,4

		FC_CAL_Bit_Low(LCD_5__PORT5, LCD_5__E);
00FF  1287  	BCF gbl_portc,5

		pt = ((in >> 4) & 0x0f);
0100  0E4C  	SWAPF FCD_LCDDis_00060_arg_in, W
0101  390F  	ANDLW 0x0F
0102  00CE  	MOVWF FCD_LCDDis_00060_1_pt
0103  300F  	MOVLW 0x0F
0104  05CE  	ANDWF FCD_LCDDis_00060_1_pt, F

		if (pt & 0x01)
0105  184E  	BTFSC FCD_LCDDis_00060_1_pt,0

		    FC_CAL_Bit_High(LCD_5__PORT0, LCD_5__BIT0);
0106  1407  	BSF gbl_portc,0

		if (pt & 0x02)
0107  18CE  	BTFSC FCD_LCDDis_00060_1_pt,1

		    FC_CAL_Bit_High(LCD_5__PORT1, LCD_5__BIT1);
0108  1487  	BSF gbl_portc,1

		if (pt & 0x04)
0109  194E  	BTFSC FCD_LCDDis_00060_1_pt,2

		    FC_CAL_Bit_High(LCD_5__PORT2, LCD_5__BIT2);
010A  1507  	BSF gbl_portc,2

		if (pt & 0x08)
010B  19CE  	BTFSC FCD_LCDDis_00060_1_pt,3

		    FC_CAL_Bit_High(LCD_5__PORT3, LCD_5__BIT3);
010C  1587  	BSF gbl_portc,3

		if (mask)
010D  08CD  	MOVF FCD_LCDDis_00060_arg_mask, F
010E  1D03  	BTFSS STATUS,Z

		    FC_CAL_Bit_High(LCD_5__PORT4, LCD_5__RS);
010F  1607  	BSF gbl_portc,4

		LCD_5__DELAY;
0110  300A  	MOVLW 0x0A
0111  00CF  	MOVWF delay_10us_00000_arg_del
0112  203D  	CALL delay_10us_00000

		FC_CAL_Bit_High (LCD_5__PORT5, LCD_5__E);
0113  1687  	BSF gbl_portc,5

		LCD_5__DELAY;
0114  300A  	MOVLW 0x0A
0115  00CF  	MOVWF delay_10us_00000_arg_del
0116  203D  	CALL delay_10us_00000

		FC_CAL_Bit_Low (LCD_5__PORT5, LCD_5__E);
0117  1287  	BCF gbl_portc,5

		pt = (in & 0x0f);
0118  300F  	MOVLW 0x0F
0119  054C  	ANDWF FCD_LCDDis_00060_arg_in, W
011A  00CE  	MOVWF FCD_LCDDis_00060_1_pt

		LCD_5__DELAY;
011B  300A  	MOVLW 0x0A
011C  00CF  	MOVWF delay_10us_00000_arg_del
011D  203D  	CALL delay_10us_00000

		FC_CAL_Bit_Low(LCD_5__PORT0, LCD_5__BIT0);
011E  1007  	BCF gbl_portc,0

		FC_CAL_Bit_Low(LCD_5__PORT1, LCD_5__BIT1);
011F  1087  	BCF gbl_portc,1

		FC_CAL_Bit_Low(LCD_5__PORT2, LCD_5__BIT2);
0120  1107  	BCF gbl_portc,2

		FC_CAL_Bit_Low(LCD_5__PORT3, LCD_5__BIT3);
0121  1187  	BCF gbl_portc,3

		FC_CAL_Bit_Low(LCD_5__PORT4, LCD_5__RS);
0122  1207  	BCF gbl_portc,4

		FC_CAL_Bit_Low(LCD_5__PORT5, LCD_5__E);
0123  1287  	BCF gbl_portc,5

		if (pt & 0x01)
0124  184E  	BTFSC FCD_LCDDis_00060_1_pt,0

		    FC_CAL_Bit_High(LCD_5__PORT0, LCD_5__BIT0);
0125  1407  	BSF gbl_portc,0

		if (pt & 0x02)
0126  18CE  	BTFSC FCD_LCDDis_00060_1_pt,1

		    FC_CAL_Bit_High(LCD_5__PORT1, LCD_5__BIT1);
0127  1487  	BSF gbl_portc,1

		if (pt & 0x04)
0128  194E  	BTFSC FCD_LCDDis_00060_1_pt,2

		    FC_CAL_Bit_High(LCD_5__PORT2, LCD_5__BIT2);
0129  1507  	BSF gbl_portc,2

		if (pt & 0x08)
012A  19CE  	BTFSC FCD_LCDDis_00060_1_pt,3

		    FC_CAL_Bit_High(LCD_5__PORT3, LCD_5__BIT3);
012B  1587  	BSF gbl_portc,3

		if (mask)
012C  08CD  	MOVF FCD_LCDDis_00060_arg_mask, F
012D  1D03  	BTFSS STATUS,Z

		    FC_CAL_Bit_High(LCD_5__PORT4, LCD_5__RS);
012E  1607  	BSF gbl_portc,4

		LCD_5__DELAY;
012F  300A  	MOVLW 0x0A
0130  00CF  	MOVWF delay_10us_00000_arg_del
0131  203D  	CALL delay_10us_00000

		FC_CAL_Bit_High (LCD_5__PORT5, LCD_5__E);
0132  1687  	BSF gbl_portc,5

		LCD_5__DELAY;
0133  300A  	MOVLW 0x0A
0134  00CF  	MOVWF delay_10us_00000_arg_del
0135  203D  	CALL delay_10us_00000

		FC_CAL_Bit_Low (LCD_5__PORT5, LCD_5__E);
0136  1287  	BCF gbl_portc,5

		LCD_5__DELAY;
0137  300A  	MOVLW 0x0A
0138  00CF  	MOVWF delay_10us_00000_arg_del
0139  203D  	CALL delay_10us_00000


}
013A  0008  	RETURN


void FCD_LCDDisplay0_Start()

{
	
		FC_CAL_Bit_Low_DDR(LCD_5__PORT0, LCD_5__TRIS0, LCD_5__BIT0);
023A  1683  	BSF STATUS, RP0
023B  1303  	BCF STATUS, RP1
023C  1007  	BCF gbl_trisc,0
023D  1283  	BCF STATUS, RP0
023E  1007  	BCF gbl_portc,0

		FC_CAL_Bit_Low_DDR(LCD_5__PORT1, LCD_5__TRIS1, LCD_5__BIT1);
023F  1683  	BSF STATUS, RP0
0240  1087  	BCF gbl_trisc,1
0241  1283  	BCF STATUS, RP0
0242  1087  	BCF gbl_portc,1

		FC_CAL_Bit_Low_DDR(LCD_5__PORT2, LCD_5__TRIS2, LCD_5__BIT2);
0243  1683  	BSF STATUS, RP0
0244  1107  	BCF gbl_trisc,2
0245  1283  	BCF STATUS, RP0
0246  1107  	BCF gbl_portc,2

		FC_CAL_Bit_Low_DDR(LCD_5__PORT3, LCD_5__TRIS3, LCD_5__BIT3);
0247  1683  	BSF STATUS, RP0
0248  1187  	BCF gbl_trisc,3
0249  1283  	BCF STATUS, RP0
024A  1187  	BCF gbl_portc,3

		FC_CAL_Bit_Low_DDR(LCD_5__PORT4, LCD_5__TRIS4, LCD_5__RS);
024B  1683  	BSF STATUS, RP0
024C  1207  	BCF gbl_trisc,4
024D  1283  	BCF STATUS, RP0
024E  1207  	BCF gbl_portc,4

		FC_CAL_Bit_Low_DDR(LCD_5__PORT5, LCD_5__TRIS5, LCD_5__E);
024F  1683  	BSF STATUS, RP0
0250  1287  	BCF gbl_trisc,5
0251  1283  	BCF STATUS, RP0
0252  1287  	BCF gbl_portc,5


		Wdt_Delay_Ms(12);
0253  300C  	MOVLW 0x0C
0254  00C7  	MOVWF Wdt_Delay__0003E_arg_delay
0255  2079  	CALL Wdt_Delay__0003E


		FCD_LCDDisplay0_RawSend(0x33, 0);
0256  3033  	MOVLW 0x33
0257  00CC  	MOVWF FCD_LCDDis_00060_arg_in
0258  01CD  	CLRF FCD_LCDDis_00060_arg_mask
0259  20FA  	CALL FCD_LCDDis_00060

		Wdt_Delay_Ms(2);
025A  3002  	MOVLW 0x02
025B  00C7  	MOVWF Wdt_Delay__0003E_arg_delay
025C  2079  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x33, 0);
025D  3033  	MOVLW 0x33
025E  00CC  	MOVWF FCD_LCDDis_00060_arg_in
025F  01CD  	CLRF FCD_LCDDis_00060_arg_mask
0260  20FA  	CALL FCD_LCDDis_00060

		Wdt_Delay_Ms(2);
0261  3002  	MOVLW 0x02
0262  00C7  	MOVWF Wdt_Delay__0003E_arg_delay
0263  2079  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x32, 0);
0264  3032  	MOVLW 0x32
0265  00CC  	MOVWF FCD_LCDDis_00060_arg_in
0266  01CD  	CLRF FCD_LCDDis_00060_arg_mask
0267  20FA  	CALL FCD_LCDDis_00060

		Wdt_Delay_Ms(2);
0268  3002  	MOVLW 0x02
0269  00C7  	MOVWF Wdt_Delay__0003E_arg_delay
026A  2079  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x2c, 0);
026B  302C  	MOVLW 0x2C
026C  00CC  	MOVWF FCD_LCDDis_00060_arg_in
026D  01CD  	CLRF FCD_LCDDis_00060_arg_mask
026E  20FA  	CALL FCD_LCDDis_00060

		Wdt_Delay_Ms(2);
026F  3002  	MOVLW 0x02
0270  00C7  	MOVWF Wdt_Delay__0003E_arg_delay
0271  2079  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x06, 0);
0272  3006  	MOVLW 0x06
0273  00CC  	MOVWF FCD_LCDDis_00060_arg_in
0274  01CD  	CLRF FCD_LCDDis_00060_arg_mask
0275  20FA  	CALL FCD_LCDDis_00060

		Wdt_Delay_Ms(2);
0276  3002  	MOVLW 0x02
0277  00C7  	MOVWF Wdt_Delay__0003E_arg_delay
0278  2079  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x0c, 0);
0279  300C  	MOVLW 0x0C
027A  00CC  	MOVWF FCD_LCDDis_00060_arg_in
027B  01CD  	CLRF FCD_LCDDis_00060_arg_mask
027C  20FA  	CALL FCD_LCDDis_00060

		Wdt_Delay_Ms(2);
027D  3002  	MOVLW 0x02
027E  00C7  	MOVWF Wdt_Delay__0003E_arg_delay
027F  2079  	CALL Wdt_Delay__0003E


		//clear the display
		FCD_LCDDisplay0_RawSend(0x01, 0);
0280  3001  	MOVLW 0x01
0281  00CC  	MOVWF FCD_LCDDis_00060_arg_in
0282  01CD  	CLRF FCD_LCDDis_00060_arg_mask
0283  20FA  	CALL FCD_LCDDis_00060

		Wdt_Delay_Ms(2);
0284  3002  	MOVLW 0x02
0285  00C7  	MOVWF Wdt_Delay__0003E_arg_delay
0286  2079  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x02, 0);
0287  3002  	MOVLW 0x02
0288  00CC  	MOVWF FCD_LCDDis_00060_arg_in
0289  01CD  	CLRF FCD_LCDDis_00060_arg_mask
028A  20FA  	CALL FCD_LCDDis_00060

		Wdt_Delay_Ms(2);
028B  3002  	MOVLW 0x02
028C  00C7  	MOVWF Wdt_Delay__0003E_arg_delay
028D  2079  	CALL Wdt_Delay__0003E


}
028E  0008  	RETURN


void FCD_LCDDisplay0_Clear()

{
	
		FCD_LCDDisplay0_RawSend(0x01, 0);
0229  3001  	MOVLW 0x01
022A  1283  	BCF STATUS, RP0
022B  1303  	BCF STATUS, RP1
022C  00CC  	MOVWF FCD_LCDDis_00060_arg_in
022D  01CD  	CLRF FCD_LCDDis_00060_arg_mask
022E  20FA  	CALL FCD_LCDDis_00060

		Wdt_Delay_Ms(2);
022F  3002  	MOVLW 0x02
0230  00C7  	MOVWF Wdt_Delay__0003E_arg_delay
0231  2079  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x02, 0);
0232  3002  	MOVLW 0x02
0233  00CC  	MOVWF FCD_LCDDis_00060_arg_in
0234  01CD  	CLRF FCD_LCDDis_00060_arg_mask
0235  20FA  	CALL FCD_LCDDis_00060

		Wdt_Delay_Ms(2);
0236  3002  	MOVLW 0x02
0237  00C7  	MOVWF Wdt_Delay__0003E_arg_delay
0238  2079  	CALL Wdt_Delay__0003E


}
0239  0008  	RETURN


void FCD_LCDDisplay0_PrintASCII(MX_UINT8 Character)
{
	
		FCD_LCDDisplay0_RawSend(Character, 0x10);

}

void FCD_LCDDisplay0_Command(MX_UINT8 in)
{
	
		FCD_LCDDisplay0_RawSend(in, 0);
		Wdt_Delay_Ms(2);

}

void FCD_LCDDisplay0_Cursor(MX_UINT8 x, MX_UINT8 y)
{
	
	  #if (LCD_5__ROWCNT == 1)
	    y=0x80;
	  #endif

	  #if (LCD_5__ROWCNT == 2)
		if (y==0)
			y=0x80;
		else
			y=0xc0;
	  #endif

	  #if (LCD_5__ROWCNT == 4)
		if (y==0)
			y=0x80;
		else if (y==1)
			y=0xc0;

		#if (LCD_5__COLCNT == 16)
			else if (y==2)
				y=0x90;
			else
				y=0xd0;
		#endif

		#if (LCD_5__COLCNT == 20)
			else if (y==2)
				y=0x94;
			else
				y=0xd4;
		#endif
	  #endif

		FCD_LCDDisplay0_RawSend(y+x, 0);
		Wdt_Delay_Ms(2);

}

void FCD_LCDDisplay0_PrintNumber(MX_SINT16 Number)

{
	
		MX_SINT16 tmp_int;
		MX_UINT8 tmp_byte;

		if (Number < 0)
013B  1FC8  	BTFSS FCD_LCDDis_00066_arg_Number+D'1',7
013C  294A  	GOTO	label16
014A        label16

		{
			FCD_LCDDisplay0_RawSend('-', 0x10);
013D  302D  	MOVLW 0x2D
013E  00CC  	MOVWF FCD_LCDDis_00060_arg_in
013F  3010  	MOVLW 0x10
0140  00CD  	MOVWF FCD_LCDDis_00060_arg_mask
0141  20FA  	CALL FCD_LCDDis_00060

			Number = 0 - Number;
0142  0847  	MOVF FCD_LCDDis_00066_arg_Number, W
0143  3C00  	SUBLW 0x00
0144  00CC  	MOVWF CompTempVar2236
0145  09C8  	COMF FCD_LCDDis_00066_arg_Number+D'1', F
0146  1803  	BTFSC STATUS,C
0147  0AC8  	INCF FCD_LCDDis_00066_arg_Number+D'1', F
0148  084C  	MOVF CompTempVar2236, W
0149  00C7  	MOVWF FCD_LCDDis_00066_arg_Number

		}

		tmp_int = Number;
014A  0847  	MOVF FCD_LCDDis_00066_arg_Number, W
014B  00C9  	MOVWF FCD_LCDDis_00066_1_tmp_int
014C  0848  	MOVF FCD_LCDDis_00066_arg_Number+D'1', W
014D  00CA  	MOVWF FCD_LCDDis_00066_1_tmp_int+D'1'

		if (Number >= 10000)
014E  3027  	MOVLW 0x27
014F  0248  	SUBWF FCD_LCDDis_00066_arg_Number+D'1', W
0150  1D03  	BTFSS STATUS,Z
0151  2954  	GOTO	label17
0152  3010  	MOVLW 0x10
0153  0247  	SUBWF FCD_LCDDis_00066_arg_Number, W
0154        label17
0154  1C03  	BTFSS STATUS,C
0155  2982  	GOTO	label21
0156  1BC8  	BTFSC FCD_LCDDis_00066_arg_Number+D'1',7
0157  2982  	GOTO	label21

		{
			tmp_byte = tmp_int / 10000;
0158  01D0  	CLRF CompTempVar2239
0159  0849  	MOVF FCD_LCDDis_00066_1_tmp_int, W
015A  00CC  	MOVWF __div_16_1_00003_arg_a
015B  084A  	MOVF FCD_LCDDis_00066_1_tmp_int+D'1', W
015C  00CD  	MOVWF __div_16_1_00003_arg_a+D'1'
015D  1FCA  	BTFSS FCD_LCDDis_00066_1_tmp_int+D'1',7
015E  2965  	GOTO	label18
015F  09CC  	COMF __div_16_1_00003_arg_a, F
0160  09CD  	COMF __div_16_1_00003_arg_a+D'1', F
0161  0ACC  	INCF __div_16_1_00003_arg_a, F
0162  1903  	BTFSC STATUS,Z
0163  0ACD  	INCF __div_16_1_00003_arg_a+D'1', F
0164  0AD0  	INCF CompTempVar2239, F
0165        label18
0165  3010  	MOVLW 0x10
0166  00CE  	MOVWF __div_16_1_00003_arg_b
0167  3027  	MOVLW 0x27
0168  00CF  	MOVWF __div_16_1_00003_arg_b+D'1'
0169  205A  	CALL __div_16_1_00003
016A  0855  	MOVF CompTempVarRet212, W
016B  00CB  	MOVWF FCD_LCDDis_00066_1_tmp_byte
016C  1C50  	BTFSS CompTempVar2239,0
016D  2970  	GOTO	label19
016E  09CB  	COMF FCD_LCDDis_00066_1_tmp_byte, F
016F  0ACB  	INCF FCD_LCDDis_00066_1_tmp_byte, F
0170        label19

			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);
0170  084B  	MOVF FCD_LCDDis_00066_1_tmp_byte, W
0171  3E30  	ADDLW 0x30
0172  00CC  	MOVWF FCD_LCDDis_00060_arg_in
0173  3010  	MOVLW 0x10
0174  00CD  	MOVWF FCD_LCDDis_00060_arg_mask
0175  20FA  	CALL FCD_LCDDis_00060


			while (tmp_byte > 0)
0176        label20
0176  084B  	MOVF FCD_LCDDis_00066_1_tmp_byte, W
0177  3C00  	SUBLW 0x00
0178  1803  	BTFSC STATUS,C
0179  2982  	GOTO	label21
0181  2976  	GOTO	label20
0182        label21

			{
				tmp_int = tmp_int - 10000;
017A  3010  	MOVLW 0x10
017B  02C9  	SUBWF FCD_LCDDis_00066_1_tmp_int, F
017C  3027  	MOVLW 0x27
017D  1C03  	BTFSS STATUS,C
017E  3028  	MOVLW 0x28
017F  02CA  	SUBWF FCD_LCDDis_00066_1_tmp_int+D'1', F

				tmp_byte--;
0180  03CB  	DECF FCD_LCDDis_00066_1_tmp_byte, F

			}
		}
		if (Number >= 1000)
0182  3003  	MOVLW 0x03
0183  0248  	SUBWF FCD_LCDDis_00066_arg_Number+D'1', W
0184  1D03  	BTFSS STATUS,Z
0185  2988  	GOTO	label22
0186  30E8  	MOVLW 0xE8
0187  0247  	SUBWF FCD_LCDDis_00066_arg_Number, W
0188        label22
0188  1C03  	BTFSS STATUS,C
0189  29B8  	GOTO	label26
018A  1BC8  	BTFSC FCD_LCDDis_00066_arg_Number+D'1',7
018B  29B8  	GOTO	label26

		{
			tmp_byte = tmp_int / 1000;
018C  01D1  	CLRF CompTempVar2243
018D  0849  	MOVF FCD_LCDDis_00066_1_tmp_int, W
018E  00CC  	MOVWF __div_16_1_00003_arg_a
018F  084A  	MOVF FCD_LCDDis_00066_1_tmp_int+D'1', W
0190  00CD  	MOVWF __div_16_1_00003_arg_a+D'1'
0191  1FCA  	BTFSS FCD_LCDDis_00066_1_tmp_int+D'1',7
0192  2999  	GOTO	label23
0193  09CC  	COMF __div_16_1_00003_arg_a, F
0194  09CD  	COMF __div_16_1_00003_arg_a+D'1', F
0195  0ACC  	INCF __div_16_1_00003_arg_a, F
0196  1903  	BTFSC STATUS,Z
0197  0ACD  	INCF __div_16_1_00003_arg_a+D'1', F
0198  0AD1  	INCF CompTempVar2243, F
0199        label23
0199  30E8  	MOVLW 0xE8
019A  00CE  	MOVWF __div_16_1_00003_arg_b
019B  3003  	MOVLW 0x03
019C  00CF  	MOVWF __div_16_1_00003_arg_b+D'1'
019D  205A  	CALL __div_16_1_00003
019E  0855  	MOVF CompTempVarRet212, W
019F  00D0  	MOVWF CompTempVar2242
01A0  1C51  	BTFSS CompTempVar2243,0
01A1  29A4  	GOTO	label24
01A2  09D0  	COMF CompTempVar2242, F
01A3  0AD0  	INCF CompTempVar2242, F
01A4        label24
01A4  0850  	MOVF CompTempVar2242, W
01A5  00CB  	MOVWF FCD_LCDDis_00066_1_tmp_byte

			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);
01A6  084B  	MOVF FCD_LCDDis_00066_1_tmp_byte, W
01A7  3E30  	ADDLW 0x30
01A8  00CC  	MOVWF FCD_LCDDis_00060_arg_in
01A9  3010  	MOVLW 0x10
01AA  00CD  	MOVWF FCD_LCDDis_00060_arg_mask
01AB  20FA  	CALL FCD_LCDDis_00060


			while (tmp_byte > 0)
01AC        label25
01AC  084B  	MOVF FCD_LCDDis_00066_1_tmp_byte, W
01AD  3C00  	SUBLW 0x00
01AE  1803  	BTFSC STATUS,C
01AF  29B8  	GOTO	label26
01B7  29AC  	GOTO	label25
01B8        label26

			{
				tmp_int = tmp_int - 1000;
01B0  30E8  	MOVLW 0xE8
01B1  02C9  	SUBWF FCD_LCDDis_00066_1_tmp_int, F
01B2  3003  	MOVLW 0x03
01B3  1C03  	BTFSS STATUS,C
01B4  3004  	MOVLW 0x04
01B5  02CA  	SUBWF FCD_LCDDis_00066_1_tmp_int+D'1', F

				tmp_byte--;
01B6  03CB  	DECF FCD_LCDDis_00066_1_tmp_byte, F

			}
		}
		if (Number >= 100)
01B8  0848  	MOVF FCD_LCDDis_00066_arg_Number+D'1', W
01B9  3A80  	XORLW 0x80
01BA  00CC  	MOVWF CompTempVar2246
01BB  3080  	MOVLW 0x80
01BC  024C  	SUBWF CompTempVar2246, W
01BD  1D03  	BTFSS STATUS,Z
01BE  29C1  	GOTO	label27
01BF  3064  	MOVLW 0x64
01C0  0247  	SUBWF FCD_LCDDis_00066_arg_Number, W
01C1        label27
01C1  1C03  	BTFSS STATUS,C
01C2  29ED  	GOTO	label31

		{
			tmp_byte = tmp_int / 100;
01C3  01D1  	CLRF CompTempVar2248
01C4  0849  	MOVF FCD_LCDDis_00066_1_tmp_int, W
01C5  00CC  	MOVWF __div_16_1_00003_arg_a
01C6  084A  	MOVF FCD_LCDDis_00066_1_tmp_int+D'1', W
01C7  00CD  	MOVWF __div_16_1_00003_arg_a+D'1'
01C8  1FCA  	BTFSS FCD_LCDDis_00066_1_tmp_int+D'1',7
01C9  29D0  	GOTO	label28
01CA  09CC  	COMF __div_16_1_00003_arg_a, F
01CB  09CD  	COMF __div_16_1_00003_arg_a+D'1', F
01CC  0ACC  	INCF __div_16_1_00003_arg_a, F
01CD  1903  	BTFSC STATUS,Z
01CE  0ACD  	INCF __div_16_1_00003_arg_a+D'1', F
01CF  0AD1  	INCF CompTempVar2248, F
01D0        label28
01D0  3064  	MOVLW 0x64
01D1  00CE  	MOVWF __div_16_1_00003_arg_b
01D2  01CF  	CLRF __div_16_1_00003_arg_b+D'1'
01D3  205A  	CALL __div_16_1_00003
01D4  0855  	MOVF CompTempVarRet212, W
01D5  00D0  	MOVWF CompTempVar2247
01D6  1C51  	BTFSS CompTempVar2248,0
01D7  29DA  	GOTO	label29
01D8  09D0  	COMF CompTempVar2247, F
01D9  0AD0  	INCF CompTempVar2247, F
01DA        label29
01DA  0850  	MOVF CompTempVar2247, W
01DB  00CB  	MOVWF FCD_LCDDis_00066_1_tmp_byte

			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);
01DC  084B  	MOVF FCD_LCDDis_00066_1_tmp_byte, W
01DD  3E30  	ADDLW 0x30
01DE  00CC  	MOVWF FCD_LCDDis_00060_arg_in
01DF  3010  	MOVLW 0x10
01E0  00CD  	MOVWF FCD_LCDDis_00060_arg_mask
01E1  20FA  	CALL FCD_LCDDis_00060


			while (tmp_byte > 0)
01E2        label30
01E2  084B  	MOVF FCD_LCDDis_00066_1_tmp_byte, W
01E3  3C00  	SUBLW 0x00
01E4  1803  	BTFSC STATUS,C
01E5  29ED  	GOTO	label31
01EC  29E2  	GOTO	label30
01ED        label31

			{
				tmp_int = tmp_int - 100;
01E6  3064  	MOVLW 0x64
01E7  02C9  	SUBWF FCD_LCDDis_00066_1_tmp_int, F
01E8  08CA  	MOVF FCD_LCDDis_00066_1_tmp_int+D'1', F
01E9  1C03  	BTFSS STATUS,C
01EA  03CA  	DECF FCD_LCDDis_00066_1_tmp_int+D'1', F

				tmp_byte--;
01EB  03CB  	DECF FCD_LCDDis_00066_1_tmp_byte, F

			}
		}
		if (Number >= 10)
01ED  0848  	MOVF FCD_LCDDis_00066_arg_Number+D'1', W
01EE  3A80  	XORLW 0x80
01EF  00CC  	MOVWF CompTempVar2251
01F0  3080  	MOVLW 0x80
01F1  024C  	SUBWF CompTempVar2251, W
01F2  1D03  	BTFSS STATUS,Z
01F3  29F6  	GOTO	label32
01F4  300A  	MOVLW 0x0A
01F5  0247  	SUBWF FCD_LCDDis_00066_arg_Number, W
01F6        label32
01F6  1C03  	BTFSS STATUS,C
01F7  2A22  	GOTO	label36

		{
			tmp_byte = tmp_int / 10;
01F8  01D1  	CLRF CompTempVar2253
01F9  0849  	MOVF FCD_LCDDis_00066_1_tmp_int, W
01FA  00CC  	MOVWF __div_16_1_00003_arg_a
01FB  084A  	MOVF FCD_LCDDis_00066_1_tmp_int+D'1', W
01FC  00CD  	MOVWF __div_16_1_00003_arg_a+D'1'
01FD  1FCA  	BTFSS FCD_LCDDis_00066_1_tmp_int+D'1',7
01FE  2A05  	GOTO	label33
01FF  09CC  	COMF __div_16_1_00003_arg_a, F
0200  09CD  	COMF __div_16_1_00003_arg_a+D'1', F
0201  0ACC  	INCF __div_16_1_00003_arg_a, F
0202  1903  	BTFSC STATUS,Z
0203  0ACD  	INCF __div_16_1_00003_arg_a+D'1', F
0204  0AD1  	INCF CompTempVar2253, F
0205        label33
0205  300A  	MOVLW 0x0A
0206  00CE  	MOVWF __div_16_1_00003_arg_b
0207  01CF  	CLRF __div_16_1_00003_arg_b+D'1'
0208  205A  	CALL __div_16_1_00003
0209  0855  	MOVF CompTempVarRet212, W
020A  00D0  	MOVWF CompTempVar2252
020B  1C51  	BTFSS CompTempVar2253,0
020C  2A0F  	GOTO	label34
020D  09D0  	COMF CompTempVar2252, F
020E  0AD0  	INCF CompTempVar2252, F
020F        label34
020F  0850  	MOVF CompTempVar2252, W
0210  00CB  	MOVWF FCD_LCDDis_00066_1_tmp_byte

			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);
0211  084B  	MOVF FCD_LCDDis_00066_1_tmp_byte, W
0212  3E30  	ADDLW 0x30
0213  00CC  	MOVWF FCD_LCDDis_00060_arg_in
0214  3010  	MOVLW 0x10
0215  00CD  	MOVWF FCD_LCDDis_00060_arg_mask
0216  20FA  	CALL FCD_LCDDis_00060


			while (tmp_byte > 0)
0217        label35
0217  084B  	MOVF FCD_LCDDis_00066_1_tmp_byte, W
0218  3C00  	SUBLW 0x00
0219  1803  	BTFSC STATUS,C
021A  2A22  	GOTO	label36
0221  2A17  	GOTO	label35
0222        label36

			{
				tmp_int = tmp_int - 10;
021B  300A  	MOVLW 0x0A
021C  02C9  	SUBWF FCD_LCDDis_00066_1_tmp_int, F
021D  08CA  	MOVF FCD_LCDDis_00066_1_tmp_int+D'1', F
021E  1C03  	BTFSS STATUS,C
021F  03CA  	DECF FCD_LCDDis_00066_1_tmp_int+D'1', F

				tmp_byte--;
0220  03CB  	DECF FCD_LCDDis_00066_1_tmp_byte, F

			}
		}
		FCD_LCDDisplay0_RawSend('0' + tmp_int, 0x10);
0222  0849  	MOVF FCD_LCDDis_00066_1_tmp_int, W
0223  3E30  	ADDLW 0x30
0224  00CC  	MOVWF FCD_LCDDis_00060_arg_in
0225  3010  	MOVLW 0x10
0226  00CD  	MOVWF FCD_LCDDis_00060_arg_mask
0227  20FA  	CALL FCD_LCDDis_00060


}
0228  0008  	RETURN


void FCD_LCDDisplay0_PrintString(MX_STRING String, MX_UINT8 MSZ_String)
{
	
		MX_UINT8 idx = 0;

		for (idx=0; idx<MSZ_String; idx++)
		{
			if (String[idx] == 0)
			{
				break;
			}
			FCD_LCDDisplay0_RawSend(String[idx], 0x10);
		}

}

void FCD_LCDDisplay0_ScrollDisplay(MX_UINT8 Direction, MX_UINT8 Num_Positions)
{
	
		MX_UINT8 cmd = 0;
		MX_UINT8 count;

		//Choose the direction
		switch (Direction)
		{
			case 0:
			case 'l':
			case 'L':

				cmd = 0x18;
				break;

			case 1:
			case 'r':
			case 'R':

				cmd = 0x1C;
				break;

			default:
				break;
		}

		//If direction accepted then scroll the specified amount
		if (cmd)
		{
			for (count = 0; count < Num_Positions; count++)
				FCD_LCDDisplay0_Command(cmd);
		}

}

void FCD_LCDDisplay0_ClearLine(MX_UINT8 Line)
{
	
		MX_UINT8 count;
		MX_UINT8 rowcount;

		//Define number of columns per line
		#if (LCD_5__ROWCNT == 1)
			rowcount=80;
		#endif

		#if (LCD_5__ROWCNT == 2)
			rowcount=40;
		#endif

		#if (LCD_5__ROWCNT == 4)
			#if (LCD_5__COLCNT == 16)
				rowcount=16;
			#endif
			#if (LCD_5__COLCNT == 20)
				rowcount=20;
			#endif
		#endif

		//Start at beginning of the line
		FCD_LCDDisplay0_Cursor (0, Line);

		//Send out spaces to clear line
		for (count = 0; count < rowcount; count++)
			FCD_LCDDisplay0_RawSend(' ', 0x10);

		//Move back to the beginning of the line.
		FCD_LCDDisplay0_Cursor (0, Line);

}

void FCD_LCDDisplay0_RAM_Write(MX_UINT8 nIdx, MX_UINT8 d0, MX_UINT8 d1, MX_UINT8 d2, MX_UINT8 d3, MX_UINT8 d4, MX_UINT8 d5, MX_UINT8 d6, MX_UINT8 d7)
{
	   //set CGRAM address

	   FCD_LCDDisplay0_RawSend(64 + (nIdx << 3), 0);
	   delay_ms(2);

	   //write CGRAM data
	   FCD_LCDDisplay0_RawSend(d0, 0x10);
	   FCD_LCDDisplay0_RawSend(d1, 0x10);
	   FCD_LCDDisplay0_RawSend(d2, 0x10);
	   FCD_LCDDisplay0_RawSend(d3, 0x10);
	   FCD_LCDDisplay0_RawSend(d4, 0x10);
	   FCD_LCDDisplay0_RawSend(d5, 0x10);
	   FCD_LCDDisplay0_RawSend(d6, 0x10);
	   FCD_LCDDisplay0_RawSend(d7, 0x10);

	   //Clear the display
	   FCD_LCDDisplay0_RawSend(0x01, 0);
	   delay_ms(2);
	   FCD_LCDDisplay0_RawSend(0x02, 0);
	   delay_ms(2);

}

#include "C:\Program Files (x86)\Flowcode\v5\CAL\includes.c"

//Macro implementations



void main()

{
	//Initialization
	adcon1 = 0x07;
02A0  3007  	MOVLW 0x07
02A1  1683  	BSF STATUS, RP0
02A2  1303  	BCF STATUS, RP1
02A3  009F  	MOVWF gbl_adcon1



	//Interrupt initialization code
	option_reg = 0xC0;
02A4  30C0  	MOVLW 0xC0
02A5  0081  	MOVWF gbl_option_reg



	//Call Component Macro
	//Call Component Macro: Start()
	FCD_LCDDisplay0_Start();
02A6  223A  	CALL FCD_LCDDis_00061


	//Loop
	//Loop: While 1
	while (1)
02A7        label37
0304  2AA7  	GOTO	label37

	{

		//Output
		//Output: 255 -> PORTD
		trisd = 0x00;
02A7  1683  	BSF STATUS, RP0
02A8  0188  	CLRF gbl_trisd

		portd = (255);
02A9  30FF  	MOVLW 0xFF
02AA  1283  	BCF STATUS, RP0
02AB  0088  	MOVWF gbl_portd


		//A/d conversion\
		//Call Component Macro: Voltage=ReadAsByte()
		FCV_VOLTAGE = FCD_ADC0_ReadAsByte();
02AC  228F  	CALL FCD_ADC0_R_00055
02AD  0848  	MOVF CompTempVarRet2207, W
02AE  00C4  	MOVWF gbl_FCV_VOLTAGE


		//Decision
		//Decision: voltage < 179?
		if (FCV_VOLTAGE < 179)
02AF  30B3  	MOVLW 0xB3
02B0  0244  	SUBWF gbl_FCV_VOLTAGE, W
02B1  1803  	BTFSC STATUS,C
02B2  2ABE  	GOTO	label38
02BE        label38

		{

			//Output
			//Output: 127 -> D0
			trisd = trisd & 0xFE;
02B3  30FE  	MOVLW 0xFE
02B4  1683  	BSF STATUS, RP0
02B5  0508  	ANDWF gbl_trisd, W
02B6  0088  	MOVWF gbl_trisd

			if ((127))
				portd = (portd & 0xFE) | 0x01;
02B7  30FE  	MOVLW 0xFE
02B8  1283  	BCF STATUS, RP0
02B9  0508  	ANDWF gbl_portd, W
02BA  00C7  	MOVWF CompTempVar2264
02BB  3001  	MOVLW 0x01
02BC  0447  	IORWF CompTempVar2264, W
02BD  0088  	MOVWF gbl_portd

			else
				portd = portd & 0xFE;

		// } else {

		}

		//Decision
		//Decision: voltage < 159?
		if (FCV_VOLTAGE < 159)
02BE  309F  	MOVLW 0x9F
02BF  0244  	SUBWF gbl_FCV_VOLTAGE, W
02C0  1803  	BTFSC STATUS,C
02C1  2AC7  	GOTO	label39
02C7        label39

		{

			//Output
			//Output: 63 -> PORTD
			trisd = 0x00;
02C2  1683  	BSF STATUS, RP0
02C3  0188  	CLRF gbl_trisd

			portd = (63);
02C4  303F  	MOVLW 0x3F
02C5  1283  	BCF STATUS, RP0
02C6  0088  	MOVWF gbl_portd


		// } else {

		}

		//Decision
		//Decision: voltage < 135?
		if (FCV_VOLTAGE < 135)
02C7  3087  	MOVLW 0x87
02C8  0244  	SUBWF gbl_FCV_VOLTAGE, W
02C9  1803  	BTFSC STATUS,C
02CA  2AD0  	GOTO	label40
02D0        label40

		{

			//Output
			//Output: 31 -> PORTD
			trisd = 0x00;
02CB  1683  	BSF STATUS, RP0
02CC  0188  	CLRF gbl_trisd

			portd = (31);
02CD  301F  	MOVLW 0x1F
02CE  1283  	BCF STATUS, RP0
02CF  0088  	MOVWF gbl_portd


		// } else {

		}

		//Decision
		//Decision: voltage < 111?
		if (FCV_VOLTAGE < 111)
02D0  306F  	MOVLW 0x6F
02D1  0244  	SUBWF gbl_FCV_VOLTAGE, W
02D2  1803  	BTFSC STATUS,C
02D3  2AD9  	GOTO	label41
02D9        label41

		{

			//Output
			//Output: 15 -> PORTD
			trisd = 0x00;
02D4  1683  	BSF STATUS, RP0
02D5  0188  	CLRF gbl_trisd

			portd = (15);
02D6  300F  	MOVLW 0x0F
02D7  1283  	BCF STATUS, RP0
02D8  0088  	MOVWF gbl_portd


		// } else {

		}

		//Decision
		//Decision: voltage < 87?
		if (FCV_VOLTAGE < 87)
02D9  3057  	MOVLW 0x57
02DA  0244  	SUBWF gbl_FCV_VOLTAGE, W
02DB  1803  	BTFSC STATUS,C
02DC  2AE2  	GOTO	label42
02E2        label42

		{

			//Output
			//Output: 7 -> PORTD
			trisd = 0x00;
02DD  1683  	BSF STATUS, RP0
02DE  0188  	CLRF gbl_trisd

			portd = (7);
02DF  3007  	MOVLW 0x07
02E0  1283  	BCF STATUS, RP0
02E1  0088  	MOVWF gbl_portd


		// } else {

		}

		//Decision
		//Decision: voltage < 63?
		if (FCV_VOLTAGE < 63)
02E2  303F  	MOVLW 0x3F
02E3  0244  	SUBWF gbl_FCV_VOLTAGE, W
02E4  1803  	BTFSC STATUS,C
02E5  2AEB  	GOTO	label43
02EB        label43

		{

			//Output
			//Output: 3 -> PORTD
			trisd = 0x00;
02E6  1683  	BSF STATUS, RP0
02E7  0188  	CLRF gbl_trisd

			portd = (3);
02E8  3003  	MOVLW 0x03
02E9  1283  	BCF STATUS, RP0
02EA  0088  	MOVWF gbl_portd


		// } else {

		}

		//Decision
		//Decision: voltage < 39?
		if (FCV_VOLTAGE < 39)
02EB  3027  	MOVLW 0x27
02EC  0244  	SUBWF gbl_FCV_VOLTAGE, W
02ED  1803  	BTFSC STATUS,C
02EE  2AF4  	GOTO	label44
02F4        label44

		{

			//Output
			//Output: 1 -> PORTD
			trisd = 0x00;
02EF  1683  	BSF STATUS, RP0
02F0  0188  	CLRF gbl_trisd

			portd = (1);
02F1  3001  	MOVLW 0x01
02F2  1283  	BCF STATUS, RP0
02F3  0088  	MOVWF gbl_portd


		// } else {

		}

		//Decision
		//Decision: voltage < 15?
		if (FCV_VOLTAGE < 15)
02F4  300F  	MOVLW 0x0F
02F5  0244  	SUBWF gbl_FCV_VOLTAGE, W
02F6  1803  	BTFSC STATUS,C
02F7  2AFC  	GOTO	label45
02FC        label45

		{

			//Output
			//Output: 0 -> PORTD
			trisd = 0x00;
02F8  1683  	BSF STATUS, RP0
02F9  0188  	CLRF gbl_trisd

			portd = (0);
02FA  1283  	BCF STATUS, RP0
02FB  0188  	CLRF gbl_portd


		// } else {

		}

		//Call Component Macro
		//Call Component Macro: Clear()
		FCD_LCDDisplay0_Clear();
02FC  2229  	CALL FCD_LCDDis_00062


		//Call Component Macro
		//Call Component Macro: PrintNumber(Voltage)
		FCD_LCDDisplay0_PrintNumber(FCV_VOLTAGE);
02FD  0844  	MOVF gbl_FCV_VOLTAGE, W
02FE  00C7  	MOVWF FCD_LCDDis_00066_arg_Number
02FF  01C8  	CLRF FCD_LCDDis_00066_arg_Number+D'1'
0300  213B  	CALL FCD_LCDDis_00066


		//Delay
		//Delay: 1 s
		delay_s(1);
0301  3001  	MOVLW 0x01
0302  00C7  	MOVWF delay_s_00000_arg_del
0303  204B  	CALL delay_s_00000



	}

	mainendloop: goto mainendloop;
}


void MX_INTERRUPT_MACRO(void)

{
}
032D  1283  	BCF STATUS, RP0
032E  1303  	BCF STATUS, RP1
032F  0E36  	SWAPF Int1BContext+D'2', W
0330  0084  	MOVWF FSR
0331  0E35  	SWAPF Int1BContext+D'1', W
0332  008A  	MOVWF PCLATH
0333  0E34  	SWAPF Int1BContext, W
0334  0083  	MOVWF STATUS
0335  0EFF  	SWAPF Int1Context, F
0336  0E7F  	SWAPF Int1Context, W
0337  0009  	RETFIE





/*********************************************************************
 *                  Flowcode CAL ADC File
 *
 * File: PIC_CAL_ADC.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 060911 | BR | Created
 * 200911 | BR | Updated to include all ADC type files
 * 110512 | BR | Fixed a bug with ADC type 13 and Vref+
 * 161012 | BR | Fixed a bug with ADC type 32 and 10 bit instead of 12 bit
 * 171212 | BR | Moved the code to begin the sample to allow for more optimised ADC readings
 */


//ADC Function Prototypes
void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge);
MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode);
void FC_CAL_Disable_ADC (void);


//ADC Global Variables
MX_UINT8 old_tris, tris_mask;
MX_UINT8 * tris_reg;					//TRIS register pointer


// ADC Type 1 Supported Devices ************************************************************
// 16F818, 16F819, 16F873A, 16F874A, 16F876A, 16F877A,
// *******************************************************************************************/

#ifdef MX_ADC_TYPE_1
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x0E;
					else
						adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x04;
					else
						adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x02;
					else
						adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x02;
					else
						adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					if (Vref == 0)
						adcon1 = 0x09;
					else
						adcon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					if (Vref == 0)
						adcon1 = 0x00;
					else
						adcon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					if (Vref == 0)
						adcon1 = 0x00;
					else
						adcon1 = 0x01;
					break;
			#endif
		}

		if (Conv_Speed > 3)										//assign conversion speed
			st_bit(adcon1, ADCS2);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x04;									//begin next conversion
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x04;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x07;
		adcon0 = 0x00;
	}
#endif


// ADC Type 2 Supported Devices ************************************************************
// 16F88
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_2
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		if (Vref == 1)											//assign VREF functionality
			st_bit(adcon1, VCFG1);

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x10;
					tris_reg = &trisa;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x20;
					tris_reg = &trisb;
					ansel = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x40;
					tris_reg = &trisb;
					ansel = 0x40;
					break;
			#endif
		}

		if (Conv_Speed > 3)										//assign conversion speed
			st_bit(adcon1, ADCS2);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x04;									//begin next conversion
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x04;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 3 Supported Devices ************************************************************
// 16F616, 16F676, 16F677, 16F684, 16F685, 16F687, 16F688, 16F689, 16F690
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_3
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = ((Conv_Speed & 0x07) << 4);				//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x10;
					tris_reg = &trisa;
					ansel = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x01;
					tris_reg = &trisc;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x02;
					tris_reg = &trisc;
					ansel = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x04;
					tris_reg = &trisc;
					ansel = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x08;
					tris_reg = &trisc;
					ansel = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x40;
					tris_reg = &trisc;
					anselh = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x80;
					tris_reg = &trisc;
					anselh = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x10;
					tris_reg = &trisb;
					anselh = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x20;
					tris_reg = &trisb;
					anselh = 0x08;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref == 1)											//assign VREF functionality
			st_bit(adcon0, VCFG);

		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel = 0x00;
		adcon0 = 0x00;
		#ifdef ANSELH
			anselh = 0x00;
		#endif
	}
#endif


// ADC Type 4 Supported Devices ************************************************************
// 16F737, 16F747, 16F767, 16F777
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_4
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = 0x00;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon1 = 0x0E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon1 = 0x0D;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon1 = 0x0C;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x0B;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					adcon1 = 0x0A;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					adcon1 = 0x09;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					adcon1 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					adcon1 = 0x07;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					adcon1 = 0x06;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x01;
					tris_reg = &trisb;
					adcon1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trisb;
					adcon1 = 0x01;
					break;
			#endif
		}

		if (Vref == 1)											//assign VREF functionality
			st_bit(adcon1, VCFG0);

		if (Conv_Speed > 3)										//assign conversion speed
			st_bit(adcon1, ADCS2);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6));					//turn ADC on
		adcon0 = adcon0 | ((Channel & 0x07) << 3);
		adcon0 = adcon0 | ((Channel & 0x08) >> 2);
		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x04;									//begin next conversion
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x04;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x07;
		adcon0 = 0x00;
	}
#endif


// ADC Type 5 Supported Devices ************************************************************
// 12F615, 12HV615, 12F675, 12F683
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_5
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		tris_reg = &trisio;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x10;
					ansel = 0x08;
					break;
			#endif
		}

		ansel = ansel | ((Conv_Speed & 0x07) << 4);				//assign conversion speed

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref == 1)											//assign VREF functionality
			st_bit(adcon0, VCFG);

		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 6 Supported Devices ************************************************************
// 16C72, 16C72A, 16CR72, 16F72, 16C73, 16C73A, 16C73B, 16F73, 16C74, 16C74A, 16C74B, 16F74,
// 16C76, 16F76, 16C77, 16F77, 16C716, 16F716
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_6
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon1 = 0x00;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					adcon1 = 0x00;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					adcon1 = 0x00;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					adcon1 = 0x00;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					adcon1 = 0x00;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			adcon1 = adcon1 + 1;

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x04;									//begin next conversion
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adres << 2);								//10-bit ADC
		}
		else
			iRetVal = adres;									//8-bit ADC

		adcon0 = adcon0 | 0x04;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x07;
		adcon0 = 0x00;
	}
#endif



// ADC Type 7 Supported Devices ************************************************************
// 16F883, 16F884, 16F886, 16F887
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_7
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = 0x00;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ansel = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ansel = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					ansel = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					anselh = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					anselh = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					anselh = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					anselh = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (13):
					tris_mask = 0x01;
					tris_reg = &trisb;
					anselh = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trisb;
					anselh = 0x20;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 2);	//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel = 0x00;
		adcon0 = 0x00;
		#ifdef ANSELH
			anselh = 0x00;
		#endif
	}
#endif


// ADC Type 8 Supported Devices ************************************************************
// 16F785
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_8
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel0 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel0 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel0 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x10;
					tris_reg = &trisa;
					ansel0 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x01;
					tris_reg = &trisc;
					ansel0 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x02;
					tris_reg = &trisc;
					ansel0 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x04;
					tris_reg = &trisc;
					ansel0 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x08;
					tris_reg = &trisc;
					ansel0 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x40;
					tris_reg = &trisc;
					ansel1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x80;
					tris_reg = &trisc;
					ansel1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ansel1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x20;
					tris_reg = &trisb;
					ansel1 = 0x08;
					break;
			#endif
		}

		adcon1 = ((Conv_Speed & 0x07) << 4);					//assign conversion rate

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG);

		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel0 = 0x00;
		adcon0 = 0x00;
		#ifdef ANSEL1
			ansel1 = 0x00;
		#endif
	}
#endif


// ADC Type 9 Supported Devices ************************************************************
// 16F913, 16F914, 16F916, 16F917, 16F946
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_9
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ansel = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ansel = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					ansel = 0x80;
					break;
			#endif
		}

		adcon1 = ((Conv_Speed & 0x07) << 4);					//assign conversion rate

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon0 = 0x00;
		ansel = 0x00;
	}
#endif


// ADC Type 10 Supported Devices ***********************************************************
// 12C671, 12C672, 12CE673, 12CE674
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_10
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		tris_reg = &trisio;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					if (Vref == 0)
						adcon1 = 0x06;
					else
						adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					if (Vref == 0)
						adcon1 = 0x02;
					else
						adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					if (Vref == 0)
						adcon1 = 0x00;
					else
						adcon1 = 0x01;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adres << 2);								//10-bit ADC
		}
		else
			iRetVal = adres;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x07;
		adcon0 = 0x00;
	}
#endif


// ADC Type 11 Supported Devices ***********************************************************
// 16C717, 16C770, 16C771
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_11
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = 0x00;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x01;
					tris_reg = &trisb;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x02;
					tris_reg = &trisb;
					ansel = 0x20;
					break;
			#endif
		}

		if (Conv_Speed > 3)										//assign conversion speed
			st_bit(adcon1, ADFM);

		if (Vref != 0)											//assign VREF functionality
		{
			st_bit(adcon1, VCFG0);
			st_bit(adcon1, VCFG1);
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x04;									//begin next conversion
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x04;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon0 = 0x00;
		ansel = 0x00;
	}
#endif


// ADC Type 12 Supported Devices ***********************************************************
// 18F6310, 18F6390, 18F6410, 18F6490, 18F6520, 18F6527, 18F6585, 18F66J60, 18F66J65,
// 18F6620, 18F6622, 18F6627, 18F6680, 18F67J60, 18F6720, 18F6722, 18F8310, 18F8390,
// 18F8410, 18F8490, 18F8520, 18F8527, 18F8585, 18F86J60, 18F86J65, 18F8620, 18F8622,
// 18F8627, 18F8680, 18F87J60, 18F8720, 18F8722, 18F96J60, 18F96J65, 18F97J60
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_12
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;								//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon1 = 0x0E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon1 = 0x0D;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon1 = 0x0C;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x0B;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					adcon1 = 0x0A;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trisf;
					adcon1 = 0x09;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trisf;
					adcon1 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trisf;
					adcon1 = 0x07;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x08;
					tris_reg = &trisf;
					adcon1 = 0x06;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x10;
					tris_reg = &trisf;
					adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x20;
					tris_reg = &trisf;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x40;
					tris_reg = &trisf;
					adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x10;
					tris_reg = &trish;
					adcon1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trish;
					adcon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_14
				case (14):
					tris_mask = 0x40;
					tris_reg = &trish;
					adcon1 = 0x00;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_15
				case (15):
					tris_mask = 0x80;
					tris_reg = &trish;
					adcon1 = 0x00;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x0f;
		adcon0 = 0x00;
	}
#endif


// ADC Type 13 Supported Devices ***********************************************************
// 18F2220, 18F2221, 18F2320, 18F2321, 18F24J10, 18F2410, 18F2420, 18F2423, 18F2450,
// 18F2455, 18F2480, 18F25J10, 18F2510, 18F2515, 18F2520, 18F2523, 18F2525, 18F2550,
// 18F2580, 18F2585, 18F2610, 18F2620, 18F2680, 18F4220, 18F4221, 18F4320, 18F4321,
// 18F44J10, 18F4410, 18F4420, 18F4423, 18F4450, 18F4455, 18F4480, 18F45J10, 18F4510,
// 18F4515, 18F4520, 18F4523, 18F4525, 18F4550, 18F4580, 18F4585, 18F4610, 18F4620,
// 18F4680, 18F4682, 18F4685
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_13
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;								//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon1 = 0x0E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon1 = 0x0D;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon1 = 0x0C;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x0B;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					adcon1 = 0x0A;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					adcon1 = 0x09;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					adcon1 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					adcon1 = 0x07;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					adcon1 = 0x06;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x01;
					tris_reg = &trisb;
					adcon1 = 0x02;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, VCFG0);								//BR changed from adcon0 05/12

		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
		  #ifdef MX_ADC_BITS_12
			iRetVal = (adresh << 4);							//12-bit ADC
			iRetVal = iRetVal | (adresl >> 4);
		  #else
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		  #endif
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x0f;
		adcon0 = 0x00;
	}
#endif


// ADC Type 14 Supported Devices ***********************************************************
// 18F2331, 18F2431, 18F4331, 18F4431
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_14
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = 0x00;											//set up ADC conversion
		adcon2 = Conv_Speed & 0x07;
		adcon3 = 0x00;
		adchs = 0x00;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon0 = 0x00;
					ansel0 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon0 = 0x04;
					ansel0 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon0 = 0x08;
					ansel0 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon0 = 0x0C;
					ansel0 = 0x08;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x10;
					tris_reg = &trisa;
					adcon0 = 0x00;
					adchs = 0x01;
					ansel0 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x20;
					tris_reg = &trisa;
					adcon0 = 0x04;
					adchs = 0x10;
					ansel0 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x01;
					tris_reg = &trise;
					adcon0 = 0x08;
					adchs = 0x04;
					ansel0 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x02;
					tris_reg = &trise;
					adcon0 = 0x0C;
					adchs = 0x40;
					ansel0 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					adcon0 = 0x00;
					adchs = 0x02;
					ansel1 = 0x01;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = adcon0 | 0x01;									//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon0 = 0x00;
		ansel0 = 0x00;
		#ifdef ANSEL1
			ansel1 = 0x00;
		#endif
	}
#endif


// ADC Type 15 Supported Devices ***********************************************************
// 18F1220, 18F1320
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_15
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;								//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon1 = 0x7E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon1 = 0x7D;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon1 = 0x7B;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x77;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x01;
					tris_reg = &trisb;
					adcon1 = 0x6F;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x02;
					tris_reg = &trisb;
					adcon1 = 0x5F;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x10;
					tris_reg = &trisb;
					adcon1 = 0x3F;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x7f;
		adcon0 = 0x00;
	}
#endif


// ADC Type 16 Supported Devices ***********************************************************
// 18F242, 18F2439, 18F248, 18F252, 18F2539, 18F258, 18F442, 18F4439, 18F448, 18F452,
// 18F4539, 18F458
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_16
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					if (Vref != 0)
						adcon1 = 0x05;
					else
						adcon1 = 0x0E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					if (Vref != 0)
						adcon1 = 0x05;
					else
						adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					if (Vref != 0)
						adcon1 = 0x03;
					else
						adcon1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x04;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					if (Vref != 0)
						adcon1 = 0x03;
					else
						adcon1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					if (Vref != 0)
						adcon1 = 0x0A;
					else
						adcon1 = 0x09;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					if (Vref != 0)
						adcon1 = 0x01;
					else
						adcon1 = 0x00;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					if (Vref != 0)
						adcon1 = 0x01;
					else
						adcon1 = 0x00;
					break;
			#endif
		}

		if (Conv_Speed > 3)										//assign conversion speed
			st_bit(adcon1, ADCS2);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x04;									//begin next conversion
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x04;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x07;
		adcon0 = 0x00;
	}
#endif


// ADC Type 17 Supported Devices ***********************************************************
// 18F1230, 18F1330
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_17
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;
		adcon1 = 0x00 | (0x01 << Channel);

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x10;
					tris_reg = &trisa;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x40;
					tris_reg = &trisa;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, VCFG0);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 18 Supported Devices ***********************************************************
// 16F722, 16F723, 16F724, 16F726, 16F727, 16F1933, 16F1934, 16F1936, 16F1937, 16F1939
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_18

	#ifndef ADREF1
		#define ADREF1 ADPREF1
	#endif

	MX_UINT8 * ansel_reg;					//ANSEL register pointer

	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = (Conv_Speed & 0x07) << 4;						//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel_reg = &ansela;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ansel_reg = &ansele;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ansel_reg = &ansele;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					ansel_reg = &ansele;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x01;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, ADREF1);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		*ansel_reg = *ansel_reg | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		*ansel_reg = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 19 Supported Devices ***********************************************************
// 18F13K50, 18F14K50, 18LF13K50, 18LF14K50
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_19
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = 0;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x10;
					tris_reg = &trisa;
					ansel = 0x08;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x01;
					tris_reg = &trisc;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x02;
					tris_reg = &trisc;
					ansel = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x04;
					tris_reg = &trisc;
					ansel = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x08;
					tris_reg = &trisc;
					adcon1 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x40;
					tris_reg = &trisc;
					anselh = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x80;
					tris_reg = &trisc;
					anselh = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x10;
					tris_reg = &trisb;
					anselh = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x20;
					tris_reg = &trisb;
					anselh = 0x08;
					break;
			#endif
		}

		adcon2 = Conv_Speed & 0x07;								//assign conversion rate

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, PVCFG0);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel = 0;
		adcon0 = 0x00;
		#ifdef ANSELH
			anselh = 0;
		#endif
	}
#endif


// ADC Type 20 Supported Devices ***********************************************************
// 18F23K20, 18F24K20, 18F25K20, 18F26K20, 18F43K20, 18F44K20, 18F45K20, 18F16K20
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_20
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = 0;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel = 0x08;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ansel = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ansel = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					adcon1 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					anselh = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					anselh = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					anselh = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					anselh = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x01;
					tris_reg = &trisb;
					anselh = 0x10;
					break;
			#endif
		}

		adcon2 = Conv_Speed & 0x07;								//assign conversion rate

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, VCFG0);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel = 0;
		adcon0 = 0x00;
		#ifdef ANSELH
			anselh = 0;
		#endif
	}
#endif


// ADC Type 21 Supported Devices ***********************************************************
// 18F2xJ11, 18F4xJ11
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_21
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = 0;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ancon0 = 0xFE;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ancon0 = 0xFD;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ancon0 = 0xFB;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ancon0 = 0xF7;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ancon0 = 0xEF;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ancon0 = 0xDF;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ancon0 = 0xBF;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					ancon0 = 0x7F;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					ancon1 = 0x1E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					ancon1 = 0x1D;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					ancon1 = 0x1B;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ancon1 = 0x17;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x01;
					tris_reg = &trisb;
					ancon1 = 0x0F;
					break;
			#endif
		}

		adcon1 = Conv_Speed & 0x07;								//assign conversion rate

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ancon0 = 0xFF;
		ancon1 = 0x1F;
		adcon0 = 0x00;
	}
#endif


// ADC Type 22 Supported Devices ***********************************************************
// 10F220, 10F222
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_22
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon0 = 0x00;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					asm("movf 1,w");
					asm("tris 6");
					adcon0 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					asm("movf 2,w");
					asm("tris 6");
					adcon0 = 0x84;
					break;
			#endif
		}

		adcon0 = adcon0 | 0x01;									//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;


		while (adcon0 & 0x02);
		if (Sample_Mode)
			iRetVal = (adres << 2);								//10-bit ADC
		else
			iRetVal = adres;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		adcon0 = 0x00;											//Reset ADC Registers
	}
#endif


// ADC Type 23 Supported Devices ***********************************************************
// 16F1826, 16F1827
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_23

	MX_UINT8 * ansel_reg;					//ANSEL register pointer

	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = (Conv_Speed & 0x07) << 4;						//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel_reg = &ansela;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x10;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x40;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x80;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x20;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x04;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x02;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, ADPREF1);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		*ansel_reg = *ansel_reg | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		*ansel_reg = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 24 Supported Devices ***********************************************************
// 18F65J50, 18F66J50, 18F66J55, 18F67J50, 18F85J50, 18F86J50, 18F86J55, 18F87J50
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_24
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = (Conv_Speed & 0x07);

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ancon0 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ancon0 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ancon0 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ancon0 = 0x08;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ancon0 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trisf;
					ancon0 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x20;
					tris_reg = &trisf;
					ancon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x40;
					tris_reg = &trisf;
					ancon1 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x10;
					tris_reg = &trish;
					ancon1 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trish;
					ancon1 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_14
				case (14):
					tris_mask = 0x40;
					tris_reg = &trish;
					ancon1 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_15
				case (15):
					tris_mask = 0x80;
					tris_reg = &trish;
					ancon1 = 0x80;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ancon0 = 0x00;
		ancon1 = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 25 Supported Devices ***********************************************************
// 18F66J93, 18F67J93, 18F86J93, 18F87J93, 18F66J90, 18F67J90, 18F86J90, 18F87J90
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_25
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon1 = 0x0E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon1 = 0x0D;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon1 = 0x0C;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x0B;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					adcon1 = 0x0A;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x80;
					tris_reg = &trisf;
					adcon1 = 0x09;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trisf;
					adcon1 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trisf;
					adcon1 = 0x07;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x08;
					tris_reg = &trisf;
					adcon1 = 0x06;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x10;
					tris_reg = &trisf;
					adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x20;
					tris_reg = &trisf;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x40;
					tris_reg = &trisf;
					adcon1 = 0x03;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, VCFG0);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x0f;
		adcon0 = 0x00;
	}
#endif


// ADC Type 26 Supported Devices ***********************************************************
// 16F1822, 16F1823, 16F1824, 16F1825, 16F1828, 16F1829
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_26

	MX_UINT8 * ansel_reg;					//ANSEL register pointer

	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = (Conv_Speed & 0x07) << 4;						//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x10;
					tris_reg = &trisa;
					ansel_reg = &ansela;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x01;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x02;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x04;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x08;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x40;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x80;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x20;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, ADPREF1);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		*ansel_reg = *ansel_reg | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		*ansel_reg = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 27 Supported Devices ***********************************************************
// 16F1946, 16F1947
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_27

	MX_UINT8 * ansel_reg;					//ANSEL register pointer

	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = (Conv_Speed & 0x07) << 4;						//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel_reg = &ansela;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x80;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x08;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x10;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x20;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x40;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisg;
					ansel_reg = &anselg;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (11):
					tris_mask = 0x08;
					tris_reg = &trisg;
					ansel_reg = &anselg;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_14
				case (11):
					tris_mask = 0x04;
					tris_reg = &trisg;
					ansel_reg = &anselg;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_15
				case (11):
					tris_mask = 0x02;
					tris_reg = &trisg;
					ansel_reg = &anselg;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_16
				case (11):
					tris_mask = 0x01;
					tris_reg = &trisg;
					ansel_reg = &anselg;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, ADPREF1);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		*ansel_reg = *ansel_reg | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		*ansel_reg = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 28 Supported Devices ***********************************************************
// 18F65K22, 18F66K22, 18F67K22, 18F85K22, 18F86K22, 18F87K22,
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_28
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ancon0 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ancon0 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ancon0 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ancon0 = 0x08;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ancon0 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x80;
					tris_reg = &trisf;
					ancon0 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trisf;
					ancon0 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trisf;
					ancon0 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x08;
					tris_reg = &trisf;
					ancon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x10;
					tris_reg = &trisf;
					ancon1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x20;
					tris_reg = &trisf;
					ancon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x40;
					tris_reg = &trisf;
					ancon1 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x10;
					tris_reg = &trish;
					ancon1 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trish;
					ancon1 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_14
				case (14):
					tris_mask = 0x40;
					tris_reg = &trish;
					ancon1 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_15
				case (15):
					tris_mask = 0x80;
					tris_reg = &trish;
					ancon1 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_16
				case (16):
					tris_mask = 0x10;
					tris_reg = &trisg;
					ancon2 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_17
				case (17):
					tris_mask = 0x08;
					tris_reg = &trisg;
					ancon2 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_18
				case (18):
					tris_mask = 0x04;
					tris_reg = &trisg;
					ancon2 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_19
				case (19):
					tris_mask = 0x02;
					tris_reg = &trisg;
					ancon2 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_20
				case (20):
					tris_mask = 0x08;
					tris_reg = &trish;
					ancon2 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_21
				case (21):
					tris_mask = 0x04;
					tris_reg = &trish;
					ancon2 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_22
				case (22):
					tris_mask = 0x02;
					tris_reg = &trish;
					ancon2 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_23
				case (23):
					tris_mask = 0x01;
					tris_reg = &trish;
					ancon2 = 0x80;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, VCFG0);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 4);							//12-bit ADC
			iRetVal = iRetVal | (adresl >> 4);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon0 = 0x00;
		ancon0 = 0x00;
		#ifdef ANCON1
			ancon1 = 0x00;
		#endif
		#ifdef ANCON2
			ancon2 = 0x00;
		#endif
	}
#endif


// ADC Type 29 Supported Devices ***********************************************************
// 18F23K22, 18F24K22, 18F25K22, 18F26K22, 18F43K22, 18F44K22, 18F45K22, 18F46K22,
// 18LF23K22, 18LF24K22, 18LF25K22, 18LF26K22, 18LF43K22, 18LF44K22, 18LF45K22, 18LF46K22,
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_29

	MX_UINT8 * ansel_reg;					//ANSEL register pointer

	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel_reg = &ansela;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ansel_reg = &ansele;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ansel_reg = &ansele;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					ansel_reg = &ansele;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x01;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_14
				case (14):
					tris_mask = 0x04;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_15
				case (15):
					tris_mask = 0x08;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_16
				case (16):
					tris_mask = 0x10;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_17
				case (17):
					tris_mask = 0x20;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_18
				case (18):
					tris_mask = 0x40;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_19
				case (19):
					tris_mask = 0x80;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_20
				case (20):
					tris_mask = 0x01;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_21
				case (21):
					tris_mask = 0x02;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_22
				case (22):
					tris_mask = 0x04;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_23
				case (23):
					tris_mask = 0x08;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_24
				case (24):
					tris_mask = 0x10;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_25
				case (25):
					tris_mask = 0x20;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_26
				case (26):
					tris_mask = 0x40;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_27
				case (27):
					tris_mask = 0x80;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, PVCFG0);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		*ansel_reg = ansel_reg | tris_mask;

		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		*ansel_reg = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 30 Supported Devices ************************************************************
// 16F870, 16F871, 16F872, 16F873, 16F874, 16F876, 16F877
// *******************************************************************************************/

#ifdef MX_ADC_TYPE_30
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)

	{
		switch (Channel)
00AB  28BC  	GOTO	label15

		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
00A8  0848  	MOVF FC_CAL_Ena_00051_arg_Channel, W
00A9  3A00  	XORLW 0x00
00AA  1D03  	BTFSS STATUS,Z

					tris_mask = 0x01;
00AC  3001  	MOVLW 0x01
00AD  00C6  	MOVWF gbl_tris_mask

					tris_reg = &trisa;
00AE  3000  	MOVLW HIGH(gbl_trisa+D'0')
00AF  00BA  	MOVWF gbl_tris_reg+D'1'
00B0  3085  	MOVLW LOW(gbl_trisa+D'0')
00B1  00B9  	MOVWF gbl_tris_reg

					if (Vref == 0)
00B2  08CA  	MOVF FC_CAL_Ena_00051_arg_Vref, F
00B3  1D03  	BTFSS STATUS,Z
00B4  28B9  	GOTO	label14
00B9        label14

						adcon1 = 0x0E;
00B5  300E  	MOVLW 0x0E
00B6  1683  	BSF STATUS, RP0
00B7  009F  	MOVWF gbl_adcon1

					else
00B8  28BC  	GOTO	label15
00BC        label15

						adcon1 = 0x05;
00B9  3005  	MOVLW 0x05
00BA  1683  	BSF STATUS, RP0
00BB  009F  	MOVWF gbl_adcon1

					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x04;
					else
						adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x02;
					else
						adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x02;
					else
						adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					if (Vref == 0)
						adcon1 = 0x09;
					else
						adcon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					if (Vref == 0)
						adcon1 = 0x00;
					else
						adcon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					if (Vref == 0)
						adcon1 = 0x00;
					else
						adcon1 = 0x01;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
00BC  1383  	BCF STATUS,IRP
00BD  1283  	BCF STATUS, RP0
00BE  183A  	BTFSC gbl_tris_reg+D'1',0
00BF  1783  	BSF STATUS,IRP
00C0  0839  	MOVF gbl_tris_reg, W
00C1  0084  	MOVWF FSR
00C2  0800  	MOVF INDF, W
00C3  00C5  	MOVWF gbl_old_tris

		*tris_reg = old_tris | tris_mask;
00C4  0846  	MOVF gbl_tris_mask, W
00C5  0445  	IORWF gbl_old_tris, W
00C6  00CC  	MOVWF CompTempVar2195
00C7  0080  	MOVWF INDF

		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
00C8  0849  	MOVF FC_CAL_Ena_00051_arg_Conv_Speed, W
00C9  00CC  	MOVWF CompTempVar2196
00CA  01CD  	CLRF CompTempVar2197
00CB  0DCC  	RLF CompTempVar2196, F
00CC  0DCD  	RLF CompTempVar2197, F
00CD  0DCC  	RLF CompTempVar2196, F
00CE  0DCD  	RLF CompTempVar2197, F
00CF  0DCC  	RLF CompTempVar2196, F
00D0  0DCD  	RLF CompTempVar2197, F
00D1  0DCC  	RLF CompTempVar2196, F
00D2  0DCD  	RLF CompTempVar2197, F
00D3  0DCC  	RLF CompTempVar2196, F
00D4  0DCD  	RLF CompTempVar2197, F
00D5  0DCC  	RLF CompTempVar2196, F
00D6  0DCD  	RLF CompTempVar2197, F
00D7  30C0  	MOVLW 0xC0
00D8  054C  	ANDWF CompTempVar2196, W
00D9  3801  	IORLW 0x01
00DA  00CF  	MOVWF CompTempVar2200
00DB  0848  	MOVF FC_CAL_Ena_00051_arg_Channel, W
00DC  00CE  	MOVWF CompTempVar2199
00DD  0DCE  	RLF CompTempVar2199, F
00DE  0DCE  	RLF CompTempVar2199, F
00DF  0DCE  	RLF CompTempVar2199, F
00E0  30F8  	MOVLW 0xF8
00E1  054E  	ANDWF CompTempVar2199, W
00E2  044F  	IORWF CompTempVar2200, W
00E3  009F  	MOVWF gbl_adcon0

		delay_us(T_Charge);										//wait the acquisition time
00E4  084B  	MOVF FC_CAL_Ena_00051_arg_T_Charge, W
00E5  00CC  	MOVWF delay_us_00000_arg_del
00E6  2010  	CALL delay_us_00000


		adcon0 = adcon0 | 0x04;									//begin next conversion
00E7  3004  	MOVLW 0x04
00E8  041F  	IORWF gbl_adcon0, W
00E9  009F  	MOVWF gbl_adcon0

	}
00EA  0008  	RETURN


	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)

	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x04);
0084        label11
0084  191F  	BTFSC gbl_adcon0,2
0085  2884  	GOTO	label11

		if (Sample_Mode)
0086  08C8  	MOVF FC_CAL_Sam_00052_arg_Sample_Mode, F
0087  1903  	BTFSC STATUS,Z
0088  289D  	GOTO	label12
009D        label12

		{
			iRetVal = (adresh << 2);							//10-bit ADC
0089  081E  	MOVF gbl_adresh, W
008A  00C9  	MOVWF FC_CAL_Sam_00052_1_iRetVal
008B  01CA  	CLRF FC_CAL_Sam_00052_1_iRetVal+D'1'
008C  0DC9  	RLF FC_CAL_Sam_00052_1_iRetVal, F
008D  0DCA  	RLF FC_CAL_Sam_00052_1_iRetVal+D'1', F
008E  0DC9  	RLF FC_CAL_Sam_00052_1_iRetVal, F
008F  0DCA  	RLF FC_CAL_Sam_00052_1_iRetVal+D'1', F
0090  30FC  	MOVLW 0xFC
0091  05C9  	ANDWF FC_CAL_Sam_00052_1_iRetVal, F

			iRetVal = iRetVal | (adresl >> 6);
0092  1683  	BSF STATUS, RP0
0093  0C1E  	RRF gbl_adresl, W
0094  1283  	BCF STATUS, RP0
0095  00CB  	MOVWF CompTempVar2204
0096  0CCB  	RRF CompTempVar2204, F
0097  0ECB  	SWAPF CompTempVar2204, F
0098  3003  	MOVLW 0x03
0099  054B  	ANDWF CompTempVar2204, W
009A  04C9  	IORWF FC_CAL_Sam_00052_1_iRetVal, F
009B  08CA  	MOVF FC_CAL_Sam_00052_1_iRetVal+D'1', F

		}
		else
009C  28A0  	GOTO	label13
00A0        label13

			iRetVal = adresh;									//8-bit ADC
009D  081E  	MOVF gbl_adresh, W
009E  00C9  	MOVWF FC_CAL_Sam_00052_1_iRetVal
009F  01CA  	CLRF FC_CAL_Sam_00052_1_iRetVal+D'1'


		adcon0 = adcon0 | 0x04;									//begin next conversion
00A0  3004  	MOVLW 0x04
00A1  041F  	IORWF gbl_adcon0, W
00A2  009F  	MOVWF gbl_adcon0


		return (iRetVal);
00A3  0849  	MOVF FC_CAL_Sam_00052_1_iRetVal, W
00A4  00CB  	MOVWF CompTempVarRet2201
00A5  084A  	MOVF FC_CAL_Sam_00052_1_iRetVal+D'1', W
00A6  00CC  	MOVWF CompTempVarRet2201+D'1'

	}
00A7  0008  	RETURN


	void FC_CAL_Disable_ADC ()

	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
00EB  1383  	BCF STATUS,IRP
00EC  1283  	BCF STATUS, RP0
00ED  1303  	BCF STATUS, RP1
00EE  183A  	BTFSC gbl_tris_reg+D'1',0
00EF  1783  	BSF STATUS,IRP
00F0  0839  	MOVF gbl_tris_reg, W
00F1  0084  	MOVWF FSR
00F2  0845  	MOVF gbl_old_tris, W
00F3  0080  	MOVWF INDF

		adcon1 = 0x07;
00F4  3007  	MOVLW 0x07
00F5  1683  	BSF STATUS, RP0
00F6  009F  	MOVWF gbl_adcon1

		adcon0 = 0x00;
00F7  1283  	BCF STATUS, RP0
00F8  019F  	CLRF gbl_adcon0

	}
00F9  0008  	RETURN

#endif


// ADC Type 31 Supported Devices ************************************************************
// 12F510, 16F506
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_31
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon0 = (0xC1 | (Conv_Speed << 4) | (Channel << 2));	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);

		iRetVal = adres;										//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		adcon0 = 0x00;
	}
#endif


// ADC Type 32 Supported Devices ***********************************************************
// 18F2xK80, 18F4xK80, 18F6xK80
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_32
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = 0;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ancon0 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ancon0 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ancon0 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ancon0 = 0x08;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ancon0 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ancon0 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ancon0 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					ancon0 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x02;
					tris_reg = &trisb;
					ancon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ancon1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x01;
					tris_reg = &trisb;
					ancon1 = 0x04;
					break;
			#endif
		}

		adcon2 = Conv_Speed & 0x07;								//assign conversion rate

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 4);							//12-bit ADC
			iRetVal = iRetVal | (adresl >> 4);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ancon0 = 0x00;
		ancon1 = 0x00;
		adcon0 = 0x00;
	}
#endif


////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  2B05  	GOTO	_startup

0004  00FF  	MOVWF Int1Context
0005  0E03  	SWAPF STATUS, W
0006  1283  	BCF STATUS, RP0
0007  1303  	BCF STATUS, RP1
0008  00B4  	MOVWF Int1BContext
0009  0E0A  	SWAPF PCLATH, W
000A  00B5  	MOVWF Int1BContext+D'1'
000B  0E04  	SWAPF FSR, W
000C  00B6  	MOVWF Int1BContext+D'2'
000D  118A  	BCF PCLATH,3
000E  120A  	BCF PCLATH,4
000F  2B2D  	GOTO	interrupt
0010        delay_us_00000
0010        ; { delay_us ; function begin
0010        label1
0010  0000  	NOP
0011  0000  	NOP
0012  0BCC  	DECFSZ delay_us_00000_arg_del, F
0013  2810  	GOTO	label1
0014  0008  	RETURN
0015        ; } delay_us function end

0015        delay_ms_00000
0015        ; { delay_ms ; function begin
0015  08C9  	MOVF delay_ms_00000_arg_del, F
0016  1D03  	BTFSS STATUS,Z
0017  2819  	GOTO	label2
0018  0008  	RETURN
0019        label2
0019  30F5  	MOVLW 0xF5
001A        label3
001A  0000  	NOP
001B  0000  	NOP
001C  0000  	NOP
001D  0000  	NOP
001E  0000  	NOP
001F  0000  	NOP
0020  0000  	NOP
0021  0000  	NOP
0022  0000  	NOP
0023  0000  	NOP
0024  0000  	NOP
0025  0000  	NOP
0026  0000  	NOP
0027  0000  	NOP
0028  0000  	NOP
0029  0000  	NOP
002A  3EFF  	ADDLW 0xFF
002B  1D03  	BTFSS STATUS,Z
002C  281A  	GOTO	label3
002D  0000  	NOP
002E  0000  	NOP
002F  0000  	NOP
0030  0000  	NOP
0031  0000  	NOP
0032  0000  	NOP
0033  0000  	NOP
0034  0000  	NOP
0035  0000  	NOP
0036  0000  	NOP
0037  0000  	NOP
0038  0000  	NOP
0039  0000  	NOP
003A  0BC9  	DECFSZ delay_ms_00000_arg_del, F
003B  2819  	GOTO	label2
003C  0008  	RETURN
003D        ; } delay_ms function end

003D        delay_10us_00000
003D        ; { delay_10us ; function begin
003D  08CF  	MOVF delay_10us_00000_arg_del, F
003E  1D03  	BTFSS STATUS,Z
003F  2841  	GOTO	label4
0040  0008  	RETURN
0041        label4
0041  3009  	MOVLW 0x09
0042        label5
0042  0000  	NOP
0043  3EFF  	ADDLW 0xFF
0044  1D03  	BTFSS STATUS,Z
0045  2842  	GOTO	label5
0046  0000  	NOP
0047  0000  	NOP
0048  0BCF  	DECFSZ delay_10us_00000_arg_del, F
0049  2841  	GOTO	label4
004A  0008  	RETURN
004B        ; } delay_10us function end

004B        delay_s_00000
004B        ; { delay_s ; function begin
004B        label6
004B  30FA  	MOVLW 0xFA
004C  00C9  	MOVWF delay_ms_00000_arg_del
004D  2015  	CALL delay_ms_00000
004E  30FA  	MOVLW 0xFA
004F  00C9  	MOVWF delay_ms_00000_arg_del
0050  2015  	CALL delay_ms_00000
0051  30FA  	MOVLW 0xFA
0052  00C9  	MOVWF delay_ms_00000_arg_del
0053  2015  	CALL delay_ms_00000
0054  30FA  	MOVLW 0xFA
0055  00C9  	MOVWF delay_ms_00000_arg_del
0056  2015  	CALL delay_ms_00000
0057  0BC7  	DECFSZ delay_s_00000_arg_del, F
0058  284B  	GOTO	label6
0059  0008  	RETURN
005A        ; } delay_s function end

005A        __div_16_1_00003
005A        ; { __div_16_16 ; function begin
005A  01D2  	CLRF __div_16_1_00003_1_r
005B  01D3  	CLRF __div_16_1_00003_1_r+D'1'
005C  01D5  	CLRF CompTempVarRet212
005D  01D6  	CLRF CompTempVarRet212+D'1'
005E  01D4  	CLRF __div_16_1_00003_1_i
005F        label7
005F  1A54  	BTFSC __div_16_1_00003_1_i,4
0060  0008  	RETURN
0061  1003  	BCF STATUS,C
0062  0DD5  	RLF CompTempVarRet212, F
0063  0DD6  	RLF CompTempVarRet212+D'1', F
0064  0DCC  	RLF __div_16_1_00003_arg_a, F
0065  0DCD  	RLF __div_16_1_00003_arg_a+D'1', F
0066  0DD2  	RLF __div_16_1_00003_1_r, F
0067  0DD3  	RLF __div_16_1_00003_1_r+D'1', F
0068  084F  	MOVF __div_16_1_00003_arg_b+D'1', W
0069  0253  	SUBWF __div_16_1_00003_1_r+D'1', W
006A  1D03  	BTFSS STATUS,Z
006B  286E  	GOTO	label8
006C  084E  	MOVF __div_16_1_00003_arg_b, W
006D  0252  	SUBWF __div_16_1_00003_1_r, W
006E        label8
006E  1C03  	BTFSS STATUS,C
006F  2877  	GOTO	label9
0070  084E  	MOVF __div_16_1_00003_arg_b, W
0071  02D2  	SUBWF __div_16_1_00003_1_r, F
0072  084F  	MOVF __div_16_1_00003_arg_b+D'1', W
0073  1C03  	BTFSS STATUS,C
0074  03D3  	DECF __div_16_1_00003_1_r+D'1', F
0075  02D3  	SUBWF __div_16_1_00003_1_r+D'1', F
0076  1455  	BSF CompTempVarRet212,0
0077        label9
0077  0AD4  	INCF __div_16_1_00003_1_i, F
0078  285F  	GOTO	label7
0079        ; } __div_16_16 function end


0305        _startup
0305  30D5  	MOVLW 0xD5
0306  1283  	BCF STATUS, RP0
0307  1303  	BCF STATUS, RP1
0308  00A0  	MOVWF gbl_14_LSR
0309  30C4  	MOVLW 0xC4
030A  00A1  	MOVWF gbl_14_LSR+D'1'
030B  30BB  	MOVLW 0xBB
030C  00A2  	MOVWF gbl_14_LSR+D'2'
030D  30DC  	MOVLW 0xDC
030E  00A3  	MOVWF gbl_14_LSR+D'3'
030F  01A4  	CLRF gbl_15_gbl_aSig
0310  01A5  	CLRF gbl_15_gbl_aSig+D'1'
0311  01A6  	CLRF gbl_15_gbl_aSig+D'2'
0312  01A7  	CLRF gbl_15_gbl_aSig+D'3'
0313  01A8  	CLRF gbl_15_gbl_bSig
0314  01A9  	CLRF gbl_15_gbl_bSig+D'1'
0315  01AA  	CLRF gbl_15_gbl_bSig+D'2'
0316  01AB  	CLRF gbl_15_gbl_bSig+D'3'
0317  01AC  	CLRF gbl_15_gbl_zSig
0318  01AD  	CLRF gbl_15_gbl_zSig+D'1'
0319  01AE  	CLRF gbl_15_gbl_zSig+D'2'
031A  01AF  	CLRF gbl_15_gbl_zSig+D'3'
031B  01BE  	CLRF gbl_15_gbl_aExp
031C  01BF  	CLRF gbl_15_gbl_bExp
031D  01B7  	CLRF gbl_15_gbl_zExp
031E  01B8  	CLRF gbl_15_gbl_zExp+D'1'
031F  01C0  	CLRF gbl_15_gbl_aSign
0320  01C1  	CLRF gbl_15_gbl_bSign
0321  01C2  	CLRF gbl_15_gbl_zSign
0322  01C3  	CLRF gbl_15_gbl_zSigZero
0323  01B0  	CLRF gbl_15_gbl_ret
0324  01B1  	CLRF gbl_15_gbl_ret+D'1'
0325  01B2  	CLRF gbl_15_gbl_ret+D'2'
0326  01B3  	CLRF gbl_15_gbl_ret+D'3'
0327  01BC  	CLRF gbl_float_rounding_mode
0328  01BD  	CLRF gbl_float_exception_flags
0329  01BB  	CLRF gbl_float_detect_tininess
032A  118A  	BCF PCLATH,3
032B  120A  	BCF PCLATH,4
032C  2AA0  	GOTO	main

2007  3F7A  	DW 0x3F7A
